<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Git代理和取消代理</title>
      <link href="2020/11/20/Git%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%96%E6%B6%88%E4%BB%A3%E7%90%86/"/>
      <url>2020/11/20/Git%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%96%E6%B6%88%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>github clone 太慢了 (⊙ˍ⊙)</p><h3 id="1-查询代理端口："><a href="#1-查询代理端口：" class="headerlink" title="1.查询代理端口："></a>1.查询代理端口：</h3><p>windows中打开 <strong>网络和Internet设置</strong> ——&gt; <strong>代理</strong> 查看代理端口，然后下面命令中的端口修改为对应的端口。</p><h3 id="2-代理："><a href="#2-代理：" class="headerlink" title="2.代理："></a>2.代理：</h3><h4 id="1-开启代理："><a href="#1-开启代理：" class="headerlink" title="1.开启代理："></a>1.开启代理：</h4><pre><code>git config --global http.proxy http://127.0.0.1:1081 git config --global https.proxy https://127.0.0.1:1081</code></pre><h4 id="2-关闭代理："><a href="#2-关闭代理：" class="headerlink" title="2.关闭代理："></a>2.关闭代理：</h4><pre><code>git config --global --unset http.proxygit config --global --unset https.proxy</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VS Code插件推荐</title>
      <link href="2020/11/10/VS-Code%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
      <url>2020/11/10/VS-Code%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/</url>
      
        <content type="html"><![CDATA[<p>VS Code 常用的插件和配置语言插件推荐</p><h3 id="1-VS-Code-常用插件："><a href="#1-VS-Code-常用插件：" class="headerlink" title="1.VS Code 常用插件："></a>1.VS Code 常用插件：</h3><h4 id="1-汉化："><a href="#1-汉化：" class="headerlink" title="1.汉化："></a>1.汉化：</h4><ul><li>Chinese (Simplified) Language Pack for Visual Studio Code （ VS Code 的中文（简体）语言包 ）</li></ul><h4 id="2-美化类："><a href="#2-美化类：" class="headerlink" title="2.美化类："></a>2.美化类：</h4><ul><li><p>One Dark Pro ( 主题 ) 下载量：2,969,203</p></li><li><p>Dracula Official ( 主题 ) 下载量：1,691,371</p></li><li><p>vscode-icons ( 图标插件 )</p></li></ul><h4 id="3-通用辅助类："><a href="#3-通用辅助类：" class="headerlink" title="3.通用辅助类："></a>3.通用辅助类：</h4><ul><li><p>Code Spell Checker ( 拼写检查器 ) 帮助捕获常见英语单词拼写错误</p></li><li><p>Rainbow Brackets ( 彩色括号 ) </p></li><li><p>indent-rainbow ( 彩色缩进 )</p></li><li><p>Bracket Pair Colorizer 2 ( 匹配括号颜色标识 )</p></li><li><p>filesize ( 显示当前文件大小 )</p></li><li><p>Path Intellisense ( 自动填充文件路径 )</p></li><li><p>Partial Diff ( 代码比较 ) 选中一代码，右键 <em>Select Text for Compare</em>，选中另外一部分代码，右键 <em>Compare Text with Previous Selection</em> 即可</p></li><li><p>TODO Tree ( 标签高亮 ) 还可以在活动栏添加一个选项卡，它能够以不同视图展示我们标记的位置，单击对应标签就能够快速定位到指定位置</p></li></ul><h4 id="4-运行测试类："><a href="#4-运行测试类：" class="headerlink" title="4.运行测试类："></a>4.运行测试类：</h4><ul><li>Code Runner ( 运行代码 )</li></ul><h3 id="2-VS-Code-配置语言插件："><a href="#2-VS-Code-配置语言插件：" class="headerlink" title="2.VS Code 配置语言插件："></a>2.VS Code 配置语言插件：</h3><h4 id="1-C-C-："><a href="#1-C-C-：" class="headerlink" title="1.C/C++："></a>1.C/C++：</h4><ul><li>C/C++ ( 代码补全和错误提醒 )</li></ul><h4 id="2-Java："><a href="#2-Java：" class="headerlink" title="2.Java："></a>2.Java：</h4><ul><li><p>Java Extension Pack ( Java整合包 )  提示代码 要求JDK版本：JDK 11</p></li><li><p>Spring Boot Extension Pack ( Spring Boot整合包 )</p></li></ul><h4 id="3-前端："><a href="#3-前端：" class="headerlink" title="3.前端："></a>3.前端：</h4><h5 id="1-辅助类："><a href="#1-辅助类：" class="headerlink" title="1.辅助类："></a>1.辅助类：</h5><ul><li><p>Auto Close Tag ( 自动闭合HTML/XML标签 )</p></li><li><p>Auto Rename Tag ( 自动完成另一侧标签的同步修改 )</p></li><li><p>Live Server ( 本地服务器 )</p></li><li><p>Preview on Web Server ( 本地服务器+打开页面 )</p></li></ul><h5 id="2-HTML："><a href="#2-HTML：" class="headerlink" title="2.HTML："></a>2.HTML：</h5><ul><li><p>HTML Snippets ( 代码提示 )</p></li><li><p>Icon Fonts ( 图标字体库提示 )</p></li></ul><h5 id="3-CSS："><a href="#3-CSS：" class="headerlink" title="3.CSS："></a>3.CSS：</h5><ul><li><p>HTML CSS Support ( 代码提示 )</p></li><li><p>IntelliSense for CSS class names in HTML ( HTML中CSS class名字的补全 )</p></li><li><p>CSS Peek ( 快速查看定位CSS定义 )</p></li><li><p>formate: CSS/LESS/SCSS formatter ( CSS格式化代码 )</p></li></ul><h5 id="4-JavaScript"><a href="#4-JavaScript" class="headerlink" title="4.JavaScript:"></a>4.JavaScript:</h5><ul><li><p>JavaScript (ES6) code snippets ( 语法支持 )</p></li><li><p>JavaScript Snippet Pack ( 语法支持(可选) )</p></li><li><p>Atom JavaScript Snippet ( 语法支持(可选) )</p></li></ul><h5 id="5-Markdown："><a href="#5-Markdown：" class="headerlink" title="5.Markdown："></a>5.Markdown：</h5><ul><li><p>Markdown All in One ( 快捷键，目录，自动预览 )</p></li><li><p>markdownlint ( 语法纠错 )</p></li></ul><h5 id="6-jQuery-js："><a href="#6-jQuery-js：" class="headerlink" title="6.jQuery.js："></a>6.jQuery.js：</h5><ul><li>jQuery Code Snippets ( 语法支持 )</li></ul><h5 id="7-Vue-js："><a href="#7-Vue-js：" class="headerlink" title="7.Vue.js："></a>7.Vue.js：</h5><ul><li>Vetur ( 语法高亮,格式化 )</li></ul><h4 id="4-Git："><a href="#4-Git：" class="headerlink" title="4.Git："></a>4.Git：</h4><ul><li>GitLens ( 查看日志 )</li></ul><h3 id="3-摸鱼类："><a href="#3-摸鱼类：" class="headerlink" title="3.摸鱼类："></a>3.摸鱼类：</h3><ul><li><p>cloudmusic ( 网易云听歌 ) </p></li><li><p>daily anime ( 新番时刻表 )</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>摸头生成器</title>
      <link href="2020/11/02/%E6%91%B8%E5%A4%B4%E7%94%9F%E6%88%90%E5%99%A8/"/>
      <url>2020/11/02/%E6%91%B8%E5%A4%B4%E7%94%9F%E6%88%90%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>摸摸你喜欢的头。</p><p>PS：仅限好玩，不能干坏事。</p><h3 id="1-项目介绍："><a href="#1-项目介绍：" class="headerlink" title="1.项目介绍："></a>1.项目介绍：</h3><p>能摸（盘）你选择的照片。</p><h3 id="2-项目地址："><a href="#2-项目地址：" class="headerlink" title="2.项目地址："></a>2.项目地址：</h3><p><a href="https://benisland.neocities.org/petpet/">petpet generator</a></p><h3 id="3-项目使用方法："><a href="#3-项目使用方法：" class="headerlink" title="3.项目使用方法："></a>3.项目使用方法：</h3><h4 id="1-adjust-mode："><a href="#1-adjust-mode：" class="headerlink" title="1.adjust mode："></a>1.adjust mode：</h4><p>启用在预览中使用鼠标/触摸/键盘移动图像的功能。</p><h4 id="2-flip："><a href="#2-flip：" class="headerlink" title="2.flip："></a>2.flip：</h4><p>水平翻转的图片。</p><h4 id="3-size："><a href="#3-size：" class="headerlink" title="3.size："></a>3.size：</h4><p>图片的大小。</p><h4 id="4-squish："><a href="#4-squish：" class="headerlink" title="4.squish："></a>4.squish：</h4><p>垂直压缩图片。</p><h4 id="5-speed："><a href="#5-speed：" class="headerlink" title="5.speed："></a>5.speed：</h4><p>摸（盘）的速度</p><h4 id="6-expor："><a href="#6-expor：" class="headerlink" title="6.expor："></a>6.expor：</h4><p>开始制作。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JSON教程 二</title>
      <link href="2020/10/25/JSON%E6%95%99%E7%A8%8B-%E4%BA%8C/"/>
      <url>2020/10/25/JSON%E6%95%99%E7%A8%8B-%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p>JSON：JavaScript 对象表示法（<strong>J</strong>ava<strong>S</strong>cript <strong>O</strong>bject <strong>N</strong>otation）。</p><h3 id="1-JSON-parse-："><a href="#1-JSON-parse-：" class="headerlink" title="1.JSON.parse()："></a>1.JSON.parse()：</h3><p>可以使用 JSON.parse() 方法将数据转换为 JavaScript 对象。</p><pre><code>JSON.parse(text)JSON.parse(text[, reviver]) == JSON.parse(text, function (key, value)&#123;&#125;)</code></pre><ul><li>text:必需， 一个有效的 JSON 字符串。</li><li>reviver: 可选，一个转换结果的函数， 将为对象的每个成员调用此函数。</li><li>key/value（键/值）。</li></ul><h3 id="2-JSON-stringify-："><a href="#2-JSON-stringify-：" class="headerlink" title="2.JSON.stringify()："></a>2.JSON.stringify()：</h3><p>可以使用 JSON.stringify() 方法将 JavaScript 对象转换为字符串。</p><pre><code>JSON.stringify(value[, replacer[, space]])</code></pre><ul><li><p>value: 必需， 要转换的 JavaScript 值（通常为对象或数组）。</p></li><li><p>replacer: 可选。用于转换结果的函数或数组。</p><pre><code>var foo = &#123;foundation: &quot;Mozilla&quot;, model: &quot;box&quot;, week: 45, transport: &quot;car&quot;, month: 7&#125;;</code></pre><p>  如果 replacer 为函数，则 JSON.stringify 将调用该函数，并传入每个成员的键和值。使用返回值而不是原始值。如果此函数返回 undefined，则排除成员。根对象的键是一个空字符串：””。</p><pre><code>function replacer(key, value) &#123;if (typeof value === &quot;string&quot;) &#123;    return undefined;&#125;return value;&#125;var jsonString = JSON.stringify(foo, replacer);// &#123;&quot;week&quot;:45,&quot;month&quot;:7&#125;</code></pre><p>  如果 replacer 是一个数组，则仅转换该数组中具有键值的成员。成员的转换顺序与键在数组中的顺序一样。当 value 参数也为数组时，将忽略 replacer 数组。</p><pre><code>JSON.stringify(foo, [&#39;week&#39;, &#39;month&#39;]);  // &#39;&#123;&quot;week&quot;:45,&quot;month&quot;:7&#125;&#39;, 只保留 “week” 和 “month” 属性值。</code></pre></li><li><p>space: 可选，文本添加缩进、空格和换行符，如果 space 是一个数字，则返回值文本在每个级别缩进指定数目的空格，如果 space 大于 10，则文本缩进 10 个空格。space 也可以使用非数字，如：\t。</p></li></ul><h3 id="JSON-eval-："><a href="#JSON-eval-：" class="headerlink" title="JSON.eval()："></a>JSON.eval()：</h3><p>可用于将 JSON 文本转换为 JavaScript 对象。</p><pre><code>var txt = &#39;&#123;&quot;employees&quot;:[&#39; +&#39;&#123;&quot;firstName&quot;:&quot;Bill&quot;,&quot;lastName&quot;:&quot;Gates&quot; &#125;,&#39; +&#39;&#123;&quot;firstName&quot;:&quot;George&quot;,&quot;lastName&quot;:&quot;Bush&quot; &#125;,&#39; +&#39;&#123;&quot;firstName&quot;:&quot;Thomas&quot;,&quot;lastName&quot;:&quot;Carter&quot; &#125;]&#125;&#39;;var obj = eval (&quot;(&quot; + txt + &quot;)&quot;); obj.employees[1].firstName (使用)</code></pre><ul><li>eval (“(“ + txt + “)”) ：<strong>eval()</strong> 函数使用的是 JavaScript 编译器，可解析 JSON 文本，然后生成 JavaScript 对象。必须把文本包围在括号中，这样才能避免语法错误。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JSON </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSON教程 一</title>
      <link href="2020/10/22/JSON%E6%95%99%E7%A8%8B-%E4%B8%80/"/>
      <url>2020/10/22/JSON%E6%95%99%E7%A8%8B-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>JSON：JavaScript 对象表示法（<strong>J</strong>ava<strong>S</strong>cript <strong>O</strong>bject <strong>N</strong>otation）。</p><h3 id="1-什么是-JSON："><a href="#1-什么是-JSON：" class="headerlink" title="1.什么是 JSON："></a>1.什么是 JSON：</h3><ul><li>JSON 指的是 JavaScript 对象表示法（JavaScript Object Notation）</li><li>JSON 是轻量级的文本数据交换格式</li><li>JSON 独立于语言 *</li><li>JSON 具有自我描述性，更易理解</li><li>JSON 使用 JavaScript 语法来描述数据对象，但是 JSON 仍然独立于语言和平台。JSON 解析器和 JSON 库支持许多不同的编程语言。</li></ul><h3 id="2-JSON-语法："><a href="#2-JSON-语法：" class="headerlink" title="2.JSON 语法："></a>2.JSON 语法：</h3><h4 id="1-JSON-语法规则："><a href="#1-JSON-语法规则：" class="headerlink" title="1.JSON 语法规则："></a>1.JSON 语法规则：</h4><p>JSON 语法是 JavaScript 对象表示法语法的子集。</p><ul><li>数据在名称/值对中</li><li>数据由逗号分隔</li><li>花括号保存对象</li><li>方括号保存数组</li></ul><h4 id="2-JSON-名称-值对："><a href="#2-JSON-名称-值对：" class="headerlink" title="2.JSON 名称/值对："></a>2.JSON 名称/值对：</h4><p>JSON 数据的书写格式是：名称/值对。<br>名称/值对包括字段名称（在双引号中），后面写一个冒号，然后是值：</p><pre><code>&quot;firstName&quot; : &quot;John&quot;</code></pre><p>这很容易理解，等价于这条 JavaScript 语句：</p><pre><code>firstName = &quot;John&quot;</code></pre><h4 id="3-JSON-值："><a href="#3-JSON-值：" class="headerlink" title="3.JSON 值："></a>3.JSON 值：</h4><p>JSON 值可以是：</p><ul><li>数字（整数或浮点数）</li><li>字符串（在双引号中）</li><li>逻辑值（true 或 false）</li><li>数组（在方括号中）</li><li>对象（在花括号中）</li><li>null</li></ul><h4 id="4-JSON-对象："><a href="#4-JSON-对象：" class="headerlink" title="4.JSON 对象："></a>4.JSON 对象：</h4><p>JSON 对象在花括号中书写：<br>对象可以包含多个名称/值对：</p><pre><code>&#123; &quot;firstName&quot;:&quot;John&quot; , &quot;lastName&quot;:&quot;Doe&quot; &#125;</code></pre><p>这一点也容易理解，与这条 JavaScript 语句等价：</p><pre><code>firstName = &quot;John&quot;lastName = &quot;Doe&quot;</code></pre><h4 id="5-JSON-数组："><a href="#5-JSON-数组：" class="headerlink" title="5.JSON 数组："></a>5.JSON 数组：</h4><p>JSON 数组在方括号中书写：<br>数组可包含多个对象：</p><pre><code>&#123;&quot;employees&quot;: [&#123; &quot;firstName&quot;:&quot;John&quot; , &quot;lastName&quot;:&quot;Doe&quot; &#125;,&#123; &quot;firstName&quot;:&quot;Anna&quot; , &quot;lastName&quot;:&quot;Smith&quot; &#125;,&#123; &quot;firstName&quot;:&quot;Peter&quot; , &quot;lastName&quot;:&quot;Jones&quot; &#125;]&#125;</code></pre><ul><li>PS：对象 “employees” 是包含三个对象的数组。每个对象代表一条关于某人（有姓和名）的记录。</li></ul><h4 id="6-JSON-使用-JavaScript-语法："><a href="#6-JSON-使用-JavaScript-语法：" class="headerlink" title="6.JSON 使用 JavaScript 语法："></a>6.JSON 使用 JavaScript 语法：</h4><p>因为 JSON 使用 JavaScript 语法，所以无需额外的软件就能处理 JavaScript 中的 JSON。</p><pre><code>var employees = [&#123; &quot;firstName&quot;:&quot;Bill&quot; , &quot;lastName&quot;:&quot;Gates&quot; &#125;,&#123; &quot;firstName&quot;:&quot;George&quot; , &quot;lastName&quot;:&quot;Bush&quot; &#125;,&#123; &quot;firstName&quot;:&quot;Thomas&quot; , &quot;lastName&quot;: &quot;Carter&quot; &#125;];</code></pre><p>可以像这样访问 JavaScript 对象数组中的第一项：</p><pre><code>employees[0].lastName;</code></pre><p>返回的内容是：</p><pre><code>Gates</code></pre><p>可以像这样修改数据：</p><pre><code>employees[0].lastName = &quot;Jobs&quot;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> JSON </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java的三种代理模式</title>
      <link href="2020/10/20/Java%E7%9A%84%E4%B8%89%E7%A7%8D%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>2020/10/20/Java%E7%9A%84%E4%B8%89%E7%A7%8D%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>Java的三种代理模式</p><h3 id="1-定义接口或者父类："><a href="#1-定义接口或者父类：" class="headerlink" title="1.定义接口或者父类："></a>1.定义接口或者父类：</h3><h4 id="1-UserDao接口类："><a href="#1-UserDao接口类：" class="headerlink" title="1.UserDao接口类："></a>1.UserDao接口类：</h4><pre><code>public interface UserDao &#123;    public void save();&#125;</code></pre><h4 id="2-UserImpl实现类："><a href="#2-UserImpl实现类：" class="headerlink" title="2.UserImpl实现类："></a>2.UserImpl实现类：</h4><pre><code>public class UserImpl implements UserDao &#123;    @Override    public void save() &#123;        System.out.println(&quot;保存成功！！！&quot;);    &#125;&#125;</code></pre><h3 id="2-代理模式："><a href="#2-代理模式：" class="headerlink" title="2.代理模式："></a>2.代理模式：</h3><h4 id="1-静态代理："><a href="#1-静态代理：" class="headerlink" title="1.静态代理："></a>1.静态代理：</h4><h5 id="1-代理类-类名：UserProxy-："><a href="#1-代理类-类名：UserProxy-：" class="headerlink" title="1.代理类(类名：UserProxy)："></a>1.代理类(类名：UserProxy)：</h5><pre><code>public class Userproxy implements UserDao &#123;    UserDao userDao;    public Userproxy(UserDao userDao) &#123;        this.userDao = userDao;    &#125;    @Override    public void save() &#123;        System.out.println(&quot;注册完成！！！&quot;);        userDao.save();    &#125;&#125;</code></pre><h5 id="2-使用方法："><a href="#2-使用方法：" class="headerlink" title="2.使用方法："></a>2.使用方法：</h5><pre><code>UserImpl userImpl = new UserImpl();Userproxy userproxy = new Userproxy(userImpl);userproxy.save();</code></pre><h4 id="2-JDK动态代理："><a href="#2-JDK动态代理：" class="headerlink" title="2.JDK动态代理："></a>2.JDK动态代理：</h4><h5 id="1-代理类-类名：UserProxy-：-1"><a href="#1-代理类-类名：UserProxy-：-1" class="headerlink" title="1.代理类(类名：UserProxy)："></a>1.代理类(类名：UserProxy)：</h5><pre><code>public class UserProxy &#123;    private Object object;    public UserProxy(Object object) &#123;        this.object = object;    &#125;    public Object getProxy()&#123;        return Proxy.newProxyInstance(                object.getClass().getClassLoader(),                object.getClass().getInterfaces(),                new InvocationHandler() &#123;                    @Override                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;                        System.out.println(&quot;注册成功！！！&quot;);                        Object obj = method.invoke(object, args);                        System.out.println(&quot;登出成功！！！&quot;);                        return obj;                    &#125;        &#125;);    &#125;&#125;</code></pre><h5 id="2-使用方法：-1"><a href="#2-使用方法：-1" class="headerlink" title="2.使用方法："></a>2.使用方法：</h5><pre><code>UserDao userDao = new UserImpl();UserDao proxy = (UserDao) new UserProxy(userDao).getProxy();proxy.save();</code></pre><h4 id="3-Cglib动态代理："><a href="#3-Cglib动态代理：" class="headerlink" title="3.Cglib动态代理："></a>3.Cglib动态代理：</h4><p>PS：需要jar包的支持，如：Spring aop。</p><h5 id="1-代理类-类名：UserProxy-：-2"><a href="#1-代理类-类名：UserProxy-：-2" class="headerlink" title="1.代理类(类名：UserProxy)："></a>1.代理类(类名：UserProxy)：</h5><pre><code>public class UserProxy implements MethodInterceptor &#123;    private Object object;    public UserProxy(Object object)&#123;        this.object = object;    &#125;    public Object getProxy()&#123;        Enhancer en = new Enhancer();        en.setSuperclass(object.getClass());        en.setCallback(this);        return en.create();    &#125;    @Override    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;        System.out.println(&quot;注册成功！！！&quot;);        Object obj = method.invoke(object, objects);        System.out.println(&quot;登出成功！！！&quot;);        return obj;    &#125;&#125;</code></pre><h5 id="2-使用方法：-2"><a href="#2-使用方法：-2" class="headerlink" title="2.使用方法："></a>2.使用方法：</h5><pre><code>UserImpl userImpl = new UserImpl();UserImpl proxy = (UserImpl) new UserProxy(userImpl).getProxy();proxy.save();</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring使用教程 一</title>
      <link href="2020/10/14/Spring%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B-%E4%B8%80/"/>
      <url>2020/10/14/Spring%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>Spring的下载安装教程</p><h3 id="1-Spring的简单介绍："><a href="#1-Spring的简单介绍：" class="headerlink" title="1.Spring的简单介绍："></a>1.Spring的简单介绍：</h3><p>Spring框架是由于软件开发的复杂性而创建的。Spring使用的是基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性角度而言，绝大部分Java应用都可以从Spring中受益。</p><ul><li>目的：解决企业应用开发的复杂性</li><li>功能：使用基本的JavaBean代替EJB，并提供了更多的企业应用功能</li><li>范围：任何Java应用</li></ul><p>Spring是一个轻量级控制反转(IoC)和面向切面(AOP)的容器框架。</p><h3 id="2-Spring下载安装："><a href="#2-Spring下载安装：" class="headerlink" title="2.Spring下载安装："></a>2.Spring下载安装：</h3><h4 id="1-下载Spring："><a href="#1-下载Spring：" class="headerlink" title="1.下载Spring："></a>1.下载Spring：</h4><p>Spring官网：<a href="https://spring.io/">https://spring.io</a></p><ol><li>点击 <strong>Projects</strong> 选项，找到 <strong>Spring Framework</strong> 点击。</li><li>点击 <strong>GitHub</strong> 图标。</li><li>向下滑动页面，找到 <strong>Access to Binaries</strong>，并点击 <strong>Spring Framework Artifacts</strong> 链接文字。</li><li>滑动页面至最底部，有一个 <strong>Downloading a Distribution</strong>，点击 <a href="https://repo.spring.io/%E3%80%82">https://repo.spring.io/。</a></li><li>点击左侧 <strong>Artifacts</strong>。</li><li>依次点击 <strong>libs-release-local</strong> ——-&gt; <strong>org</strong> ——-&gt; <strong>springframework</strong> ——-&gt; <strong>spring</strong>。</li><li>在 <strong>spring</strong> 之下有多个版本，选择其中一个版本右键，再点击 <strong>Native Browser</strong>。</li></ol><h4 id="2-Spring安装："><a href="#2-Spring安装：" class="headerlink" title="2.Spring安装："></a>2.Spring安装：</h4><p>对应 <strong>IDE</strong> ，对应方法导入 <strong>jar</strong> 包。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git使用教程 二</title>
      <link href="2020/10/11/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B-%E4%BA%8C/"/>
      <url>2020/10/11/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B-%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p>Git的使用教程</p><h3 id="1-Git-创建仓库："><a href="#1-Git-创建仓库：" class="headerlink" title="1.Git 创建仓库："></a>1.Git 创建仓库：</h3><h4 id="1-git-init："><a href="#1-git-init：" class="headerlink" title="1.git init："></a>1.git init：</h4><p>Git 使用 git init 命令来初始化一个 Git 仓库，Git 的很多命令都需要在 Git 的仓库中运行，所以 git init 是使用 Git 的第一个命令。<br>在执行完成 git init 命令后，Git 仓库会生成一个 .git 目录，该目录包含了资源的所有元数据，其他的项目目录保持不变。</p><pre><code>git init (使用当前目录作为Git仓库)git init newrepo (在当前目录 创建newrepo文件夹 作为Git仓库)</code></pre><p>如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交：</p><pre><code>git add *.cgit add READMEgit commit -m &#39;初始化项目版本&#39;</code></pre><h4 id="2-git-clone："><a href="#2-git-clone：" class="headerlink" title="2.git clone："></a>2.git clone：</h4><p>我们使用 git clone 从现有 Git 仓库中拷贝项目（类似 svn checkout）。</p><pre><code>git clone &lt;repo&gt;git clone &lt;repo&gt; &lt;directory&gt; (克隆到指定的目录)</code></pre><ul><li>repo:Git 仓库。</li><li>directory:本地目录。</li></ul><h4 id="3-git-config："><a href="#3-git-config：" class="headerlink" title="3.git config："></a>3.git config：</h4><p>git 的设置。</p><pre><code>$ git config -e    (针对当前仓库) $ git config -e --global   (针对系统上所有仓库)$ git config --global user.name &quot;runoob&quot;$ git config --global user.email test@runoob.com  (设置提交代码时的用户信息)</code></pre><ul><li>去掉 –global 参数只对当前仓库有效。</li></ul><h3 id="2-Git-基本操作："><a href="#2-Git-基本操作：" class="headerlink" title="2.Git 基本操作："></a>2.Git 基本操作：</h3><h4 id="1-创建仓库命令："><a href="#1-创建仓库命令：" class="headerlink" title="1.创建仓库命令："></a>1.创建仓库命令：</h4><p>下表列出了 git 创建仓库的命令：</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">git init</td><td align="center">初始化仓库</td></tr><tr><td align="center">git clone</td><td align="center">拷贝一份远程仓库，也就是下载一个项目。</td></tr></tbody></table><h4 id="2-提交与修改："><a href="#2-提交与修改：" class="headerlink" title="2.提交与修改："></a>2.提交与修改：</h4><p>Git 的工作就是创建和保存你的项目的快照及与之后的快照进行对比。<br>下表列出了有关创建与提交你的项目的快照的命令：</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">git add</td><td align="center">添加文件到仓库</td></tr><tr><td align="center">git status</td><td align="center">查看仓库当前的状态，显示有变更的文件。</td></tr><tr><td align="center">git diff</td><td align="center">比较文件的不同，即暂存区和工作区的差异。</td></tr><tr><td align="center">git commit</td><td align="center">提交暂存区到本地仓库。</td></tr><tr><td align="center">git reset</td><td align="center">回退版本。</td></tr><tr><td align="center">git rm</td><td align="center">删除工作区文件。</td></tr><tr><td align="center">git mv</td><td align="center">移动或重命名工作区文件。</td></tr></tbody></table><h4 id="3-提交日志："><a href="#3-提交日志：" class="headerlink" title="3.提交日志："></a>3.提交日志：</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">git log</td><td align="center">查看历史提交记录</td></tr><tr><td align="center">git blame <file></td><td align="center">以列表形式查看指定文件的历史修改记录</td></tr></tbody></table><h4 id="4-远程操作："><a href="#4-远程操作：" class="headerlink" title="4.远程操作："></a>4.远程操作：</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">git remote</td><td align="center">远程仓库操作</td></tr><tr><td align="center">git fetch</td><td align="center">从远程获取代码库</td></tr><tr><td align="center">git pull</td><td align="center">下载远程代码并合并</td></tr><tr><td align="center">git push</td><td align="center">上传远程代码并合并</td></tr></tbody></table><h3 id="3-推送到远程仓库-模板-："><a href="#3-推送到远程仓库-模板-：" class="headerlink" title="3.推送到远程仓库(模板)："></a>3.推送到远程仓库(模板)：</h3><pre><code>git add .git commit -m &quot; &quot;  (&quot; &quot; 填写更新说明)git push -u origin master</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git使用教程 一</title>
      <link href="2020/10/10/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B-%E4%B8%80/"/>
      <url>2020/10/10/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>Git的安装教程</p><h3 id="1-Git的简单介绍："><a href="#1-Git的简单介绍：" class="headerlink" title="1.Git的简单介绍："></a>1.Git的简单介绍：</h3><p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。<br>Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。</p><h3 id="2-Git安装教学"><a href="#2-Git安装教学" class="headerlink" title="2.Git安装教学:"></a>2.Git安装教学:</h3><h4 id="1-下载Git："><a href="#1-下载Git：" class="headerlink" title="1.下载Git："></a>1.下载Git：</h4><p>Git官网：<a href="https://git-scm.com/">https://git-scm.com</a>  </p><ol><li>点击 <strong>Downloads</strong>。</li><li>再点击 <strong>Windows</strong>。</li><li>如果没有下载，选择这个版本 <strong>Git for Windows Setup</strong> 下的 <strong>64-bit Git for Windows Setup</strong>。</li></ol><h4 id="2-安装Git："><a href="#2-安装Git：" class="headerlink" title="2.安装Git："></a>2.安装Git：</h4><ol><li>进入到 Git的安装界面，并点击按钮”Next”，进入到下一步</li><li>选择Git的安装目录，目录不要包含中文和空格，并点击按钮”Next”，进入到下一步</li><li>选择配置组件，默认即可，并点击按钮”Next”，进入到下一步</li><li>设置开始菜单目录名，默认即可，并点击按钮”Next”，进入到下一步</li><li>选择默认的编辑器 (默认为Vim编辑器)，默认即可，并点击按钮”Next”，进入到下一步</li><li>选择使用命令环境，这里我们选择 “<strong>Use Git from Git Bash only</strong>“，并点击按钮”Next”，进入到下一步</li></ol><ul><li><strong>Use Git from Git Bash only</strong>：这是最谨慎的选择，因为PATH环境变量不会被修改。您只能从Git Bash中使用Git命令行工具，不能再cmd命令行中使用Git命令(推荐)</li><li><strong>Git from the command line and also from 3rd-paty software</strong>：可以在Git Bash 、cmd命令行 和 Windows PowerShell 中使用Git命令，但是会向PATH环境变量中添加一些最小的Git包装器</li><li><strong>Use Git and optional Unix toos from the Command Prompt</strong>：会在第二个选项的基础上添加一些Unix系统中的工具，会覆盖Windows工具中的一些命令，例如: “find” 和 “sort”</li></ul><ol start="7"><li>选择https传输后端，默认即可，并点击按钮”Next”，进入到下一步</li><li>选择HTTPS连接库，默认即可，并点击按钮”Next”，进入到下一步</li><li>配置行尾转换Git应该如何处理文本文件中的行尾，默认即可，并点击按钮”Next”，进入到下一步</li></ol><ul><li><strong>checkout Windows-style, commit Unix-style line endings</strong>：Git在检出文本文件时将LF转换为CRLF。当提交文本文件时，CRLF将被转换为LF。</li><li><strong>Checkout as-is, commit Unix-style line endings</strong>：当检出文本文件时，Git将不执行任何转换。当提交文本文件时，CRLF将被转换为LF。</li><li><strong>Checkout as-is, commit as-is</strong>：Git在检出或提交文本文件时不会执行任何转换操作。</li></ul><ol start="10"><li>配置终端模拟器，默认即可，并点击按钮”Next”，进入到下一步</li><li>配置额外选项，默认即可，并点击按钮”Next”，进入到下一步</li><li>实验配置选项，由于它的功能还不够健壮，这里我们默认不勾选，最后点击按钮”Install” 进行 Git安装</li><li>不需要查看 Git的视图版本说明，所以这里我们去掉View Relese Notes 前面的勾选，并点击按钮”Finish”</li></ol><h4 id="3-验证Git是否安装成功："><a href="#3-验证Git是否安装成功：" class="headerlink" title="3.验证Git是否安装成功："></a>3.验证Git是否安装成功：</h4><p>右键，点击Git Bash Here，进入到 Git终端，并输入git，会出现如下 Git相关信息：</p><pre><code>usage: git [--version] [--help] [-C &lt;path&gt;] [-c &lt;name&gt;=&lt;value&gt;]           [--exec-path[=&lt;path&gt;]] [--html-path] [--man-path] [--info-path]           [-p | --paginate | -P | --no-pager] [--no-replace-objects] [--bare]           [--git-dir=&lt;path&gt;] [--work-tree=&lt;path&gt;] [--namespace=&lt;name&gt;]           &lt;command&gt; [&lt;args&gt;]These are common Git commands used in various situations:start a working area (see also: git help tutorial)   clone             Clone a repository into a new directory   init              Create an empty Git repository or reinitialize an existing onework on the current change (see also: git help everyday)   add               Add file contents to the index   mv                Move or rename a file, a directory, or a symlink   restore           Restore working tree files   rm                Remove files from the working tree and from the index   sparse-checkout   Initialize and modify the sparse-checkoutexamine the history and state (see also: git help revisions)   bisect            Use binary search to find the commit that introduced a bug   diff              Show changes between commits, commit and working tree, etc   grep              Print lines matching a pattern   log               Show commit logs   show              Show various types of objects   status            Show the working tree statusgrow, mark and tweak your common history   branch            List, create, or delete branches   commit            Record changes to the repository   merge             Join two or more development histories together   rebase            Reapply commits on top of another base tip   reset             Reset current HEAD to the specified state   switch            Switch branches   tag               Create, list, delete or verify a tag object signed with GPGcollaborate (see also: git help workflows)   fetch             Download objects and refs from another repository   pull              Fetch from and integrate with another repository or a local branch   push              Update remote refs along with associated objects&#39;git help -a&#39; and &#39;git help -g&#39; list available subcommands and someconcept guides. See &#39;git help &lt;command&gt;&#39; or &#39;git help &lt;concept&gt;&#39;to read about a specific subcommand or concept.See &#39;git help git&#39; for an overview of the system.</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC使用教程 二</title>
      <link href="2020/10/06/JDBC%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B-%E4%BA%8C/"/>
      <url>2020/10/06/JDBC%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B-%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p>JDBC使用教程</p><h3 id="1-构建JDBC连接类-MySQL为例-："><a href="#1-构建JDBC连接类-MySQL为例-：" class="headerlink" title="1.构建JDBC连接类(MySQL为例)："></a>1.构建JDBC连接类(MySQL为例)：</h3><ol><li>导入包：需要包含包含数据库编程所需的JDBC类的包。<pre><code>import java.sql.* ;</code></pre></li><li>注册JDBC驱动程序：需要初始化驱动程序，以便可以打开与数据库的通信通道。<pre><code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</code></pre></li><li>打开一个连接：需要使用DriverManager.getConnection()方法创建一个Connection对象，它表示与数据库的物理连接。<pre><code>Connection conn = null;</code></pre></li></ol><p>conn = DriverManager.getConnection(“jdbc:mysql://hostname:port/db_name”,”db_username”, “db_password”);</p><pre><code>4. 执行查询：需要使用类型为Statement的对象来构建和提交SQL语句到数据库。</code></pre><p>Statement stmt = null;<br>ResultSet rs = null;<br>String sql = “SELECT * FROM xxx”;</p><p>stmt = conn.createStatement();<br>rs = stmt.executeQuery(sql);</p><pre><code>5. 从结果集中提取数据：需要使用相应的ResultSet.getXXX()方法从结果集中检索数据。</code></pre><p>int xxx  = rs.getInt(“xxx”);</p><p>String xxx = rs.getString(“xxx”);</p><p>where(rs.next()){<br>    xxxxxx<br>}</p><pre><code>6. 清理环境：需要明确地关闭所有数据库资源，而不依赖于JVM的垃圾收集。</code></pre><p>rs.close();<br>stmt.close();<br>conn.close();</p><pre><code>### 2.PreparedStatement使用教程：PreparedStatement可以使用占位符，是预编译的，批处理比Statement效率高，而且还能防止SQL注入。1. 创建对象：</code></pre><p>String sql = “select * from xxx where id=?”;</p><p>PreparedStatement preparedStatement = connection.prepareStatement(sql);</p><pre><code>2. 传递参数：</code></pre><p>preparedStatement.setInt(1, “xxx”);</p><p>preparedStatement.setString(1, “xxx”);</p><p>preparedStatement.setLong(1, “xxx”);</p><pre><code>3. 获取数据：</code></pre><p>ResultSet rs = null;</p><p>rs = preparedStatement.executequery();</p><pre><code>### 3.报错：#### 1.DriverManager.getConnection url参数：</code></pre><p>useUnicode=true&amp;characterEncoding=UTF-8     (指定字符的编码、解码格式。)</p><p>serverTimezone=Asia/Shanghai                (时区)<br>```</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> JDBC </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC使用教程 一</title>
      <link href="2020/10/05/JDBC%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B-%E4%B8%80/"/>
      <url>2020/10/05/JDBC%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>JDBC安装导入</p><h3 id="1-JDBC简单介绍："><a href="#1-JDBC简单介绍：" class="headerlink" title="1.JDBC简单介绍："></a>1.JDBC简单介绍：</h3><p>JDBC API是一个Java API，可以访问任何类型表列数据，特别是存储在关系数据库中的数据。JDBC代表Java数据库连接。<br>JDBC库中所包含的API通常与数据库使用于：</p><ul><li>连接到数据库</li><li>创建SQL或MySQL语句</li><li>在数据库中执行SQL或MySQL查询</li><li>查看和修改数据库中的数据记录</li></ul><h3 id="2-获取JDBC-MySQL版本-："><a href="#2-获取JDBC-MySQL版本-：" class="headerlink" title="2.获取JDBC(MySQL版本)："></a>2.获取JDBC(MySQL版本)：</h3><p>MySQL官网：<a href="https://www.mysql.com/">https://www.mysql.com</a>  </p><ol><li>点击 <strong>downloads</strong>。</li><li>滑到下面点击 <strong>MySQL Community (GPL) Downloads »</strong>。</li><li>再点击 <strong>Connector/J</strong>。</li><li>在下拉列表中选择 <strong>Platform Independent</strong>。</li><li>选择这个版本进行下载 <strong>Platform Independent (Architecture Independent), ZIP Archive</strong>。 </li><li>下载后解压 找到 <strong>mysql-connector-java-xxx.jar</strong>。 </li></ol><h3 id="3-导入工程-IDEA为例-："><a href="#3-导入工程-IDEA为例-：" class="headerlink" title="3.导入工程(IDEA为例)："></a>3.导入工程(IDEA为例)：</h3><ol><li>点击File –&gt; Project Structure。</li><li>Modules-&gt;Dependencies，点击最右侧的 + 号。</li><li>选择 JARs 。</li><li>然后就是选择你要导入的Jar包了。</li></ol><p>PS：如果是用tomcat等，要把jar包也放一份在 tomcat目录-&gt;lib 。</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> JDBC </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL使用方法 三</title>
      <link href="2020/10/04/SQL%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95-%E4%B8%89/"/>
      <url>2020/10/04/SQL%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95-%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<p>SQL 高级语法教程(MySQL用法) 二</p><h3 id="1-SQL-约束-Constraints-："><a href="#1-SQL-约束-Constraints-：" class="headerlink" title="1.SQL 约束 (Constraints)："></a>1.SQL 约束 (Constraints)：</h3><p>约束用于限制加入表的数据的类型。<br>可以在创建表时规定约束（通过 CREATE TABLE 语句），或者在表创建之后也可以（通过 ALTER TABLE 语句）。<br>我们将主要探讨以下几种约束：</p><ul><li>NOT NULL(非空)</li><li>UNIQUE(唯一键)</li><li>PRIMARY KEY(主键)</li><li>FOREIGN KEY(外键)</li><li>CHECK(限制)</li><li>DEFAULT(默认值)</li></ul><h4 id="1-NOT-NULL-非空-约束："><a href="#1-NOT-NULL-非空-约束：" class="headerlink" title="1.NOT NULL(非空) 约束："></a>1.NOT NULL(非空) 约束：</h4><p>NOT NULL(非空) 约束强制列不接受 NULL(空) 值。<br>NOT NULL(非空) 约束强制字段始终包含值。这意味着，如果不向字段添加值，就无法插入新记录或者更新记录。</p><pre><code>CREATE TABLE Persons(Id_P int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255))</code></pre><p>强制 “Id_P” 列和 “LastName” 列不接受 NULL(空) 值。</p><h4 id="2-UNIQUE-唯一键-约束："><a href="#2-UNIQUE-唯一键-约束：" class="headerlink" title="2.UNIQUE(唯一键) 约束："></a>2.UNIQUE(唯一键) 约束：</h4><p>UNIQUE(唯一键) 约束唯一标识数据库表中的每条记录。<br>UNIQUE(唯一键) 和 PRIMARY KEY(主键) 约束均为列或列集合提供了唯一性的保证。<br>PS：每个表可以有多个 UNIQUE(唯一键) 约束，但是每个表只能有一个 PRIMARY KEY(主键) 约束。<br>创建表时：</p><pre><code>UNIQUE ( 列名称 )                       (创建 UNIQUE 约束)CONSTRAINT 别名 UNIQUE ( 列1,列2 )      (如需别名 UNIQUE 约束，并定义多个列的 UNIQUE 约束)</code></pre><p>表已创建时：</p><pre><code>ALTER TABLE Persons    ADD UNIQUE ( 列名称 )                       (创建 UNIQUE 约束)或者：    ADD CONSTRAINT 别名 UNIQUE ( 列1,列2 )      (如需别名 UNIQUE 约束，并定义多个列的 UNIQUE 约束)</code></pre><p>撤销 UNIQUE 约束：</p><pre><code>ALTER TABLE PersonsDROP INDEX 别名</code></pre><h4 id="3-PRIMARY-KEY-主键-约束："><a href="#3-PRIMARY-KEY-主键-约束：" class="headerlink" title="3.PRIMARY KEY(主键) 约束："></a>3.PRIMARY KEY(主键) 约束：</h4><p>PRIMARY KEY(主键) 约束唯一标识数据库表中的每条记录。</p><ol><li>主键必须包含唯一的值。</li><li>主键列不能包含 NULL(空) 值。</li><li>每个表都应该有一个主键，并且每个表只能有一个主键。</li></ol><p>创建表时：</p><pre><code>PRIMARY KEY ( 列名称 )                       (创建 PRIMARY KEY 约束)CONSTRAINT 别名 PRIMARY KEY ( 列1,列2 )      (如需别名 PRIMARY KEY 约束，并定义多个列的 PRIMARY KEY 约束)</code></pre><p>表已创建时：</p><pre><code>ALTER TABLE Persons    ADD PRIMARY KEY ( 列名称 )                       (创建 PRIMARY KEY 约束)或者：    ADD CONSTRAINT 别名 PRIMARY KEY ( 列1,列2 )      (如需别名 PRIMARY KEY 约束，并定义多个列的 PRIMARY KEY 约束)</code></pre><p>撤销 PRIMARY KEY 约束：</p><pre><code>ALTER TABLE PersonsDROP PRIMARY KEY</code></pre><h4 id="4-FOREIGN-KEY-外键-约束："><a href="#4-FOREIGN-KEY-外键-约束：" class="headerlink" title="4.FOREIGN KEY(外键) 约束："></a>4.FOREIGN KEY(外键) 约束：</h4><p>一个表中的 FOREIGN KEY(外键) 指向另一个表中的 PRIMARY KEY(主键)。<br>创建表时：</p><pre><code>FOREIGN KEY ( 列名称 ) REFERENCES 主键表 ( 主键列 )                      (创建 FOREIGN KEY 约束)CONSTRAINT 别名 FOREIGN KEY ( 列名称 ) REFERENCES 主键表 ( 主键列 )      (如需别名 FOREIGN KEY 约束，并定义多个列的 FOREIGN KEY 约束)</code></pre><p>表已创建时：</p><pre><code>ALTER TABLE Persons    ADD FOREIGN KEY ( 列名称 ) REFERENCES 主键表 ( 主键列 )                       (创建 FOREIGN KEY 约束)或者：    ADD CONSTRAINT 别名 FOREIGN KEY ( 列名称 ) REFERENCES 主键表 ( 主键列 )       (如需别名 FOREIGN KEY 约束，并定义多个列的 FOREIGN KEY 约束)</code></pre><p>撤销 FOREIGN KEY 约束：</p><pre><code>ALTER TABLE PersonsDROP FOREIGN KEY  ( 列名称 )</code></pre><h4 id="5-CHECK-限制-约束："><a href="#5-CHECK-限制-约束：" class="headerlink" title="5.CHECK(限制) 约束："></a>5.CHECK(限制) 约束：</h4><p>用于限制列中的值的范围。<br>创建表时：</p><pre><code>CHECK ( 列名称 &gt; 0 )                                        (创建 CHECK 约束,规定 列 必须只包含大于 0 的整数。)CONSTRAINT 别名 CHECK ( 列名称 &gt; 0 AND 列名称 = &#39;xxx&#39; )      (如需别名 CHECK 约束，并定义多个列的 CHECK 约束)</code></pre><p>表已创建时：</p><pre><code>ALTER TABLE Persons    ADD CHECK ( 列名称 &gt; 0 )                                        (创建 CHECK 约束,规定 列 必须只包含大于 0 的整数。)或者：    ADD CONSTRAINT 别名 CHECK ( 列名称 &gt; 0 AND 列名称 = &#39;xxx&#39; )      (如需别名 CHECK 约束，并定义多个列的 CHECK 约束)</code></pre><p>撤销 UNIQUE 约束：</p><pre><code>ALTER TABLE PersonsDROP CHECK 别名</code></pre><h4 id="6-DEFAULT-默认值-约束："><a href="#6-DEFAULT-默认值-约束：" class="headerlink" title="6.DEFAULT(默认值) 约束："></a>6.DEFAULT(默认值) 约束：</h4><p>用于向列中插入默认值。<br>创建表时：</p><pre><code>列名称 数据类型 DEFAULT ( 列名称 )                          (创建 DEFAULT 约束)OrderDate( 订单日期 ) date( 日期 ) DEFAULT GETDATE()      (使用类似 GETDATE() 这样的函数，DEFAULT 约束也可以用于插入系统值)</code></pre><p>表已创建时：</p><pre><code>ALTER TABLE PersonsALTER 列名称 SET DEFAULT &#39; 内容 &#39;                       (创建 DEFAULT 约束)</code></pre><p>撤销 UNIQUE 约束：</p><pre><code>ALTER TABLE PersonsALTER 列名称 DROP DEFAULT</code></pre><h3 id="2-SQL-CREATE-INDEX-语句："><a href="#2-SQL-CREATE-INDEX-语句：" class="headerlink" title="2.SQL CREATE INDEX 语句："></a>2.SQL CREATE INDEX 语句：</h3><p>用于在表中创建索引。</p><pre><code>    CREATE INDEX 索引名称           (创建索引)    ON 表名称 ( 列名称 )或者：    CREATE UNIQUE INDEX 索引名称    (创建唯一索引)    ON 表名称 ( 列名称 )</code></pre><h3 id="3-DROP-语句："><a href="#3-DROP-语句：" class="headerlink" title="3.DROP 语句："></a>3.DROP 语句：</h3><p>删除索引、表和数据库。</p><pre><code>ALTER TABLE 表名称 DROP INDEX 索引名称   (删除表格中的索引)DROP TABLE 表名称                       (删除表 (表的结构、属性以及索引也会被删除) )DROP DATABASE 数据库名称                 (删除数据库)TRUNCATE TABLE 表名称                   (仅仅删除表格中的数据)</code></pre><h3 id="4-SQL-ALTER-TABLE-语句："><a href="#4-SQL-ALTER-TABLE-语句：" class="headerlink" title="4.SQL ALTER TABLE 语句："></a>4.SQL ALTER TABLE 语句：</h3><p>用于在已有的表中添加、修改或删除列。</p><pre><code>ALTER TABLE 表名称    ADD 列名称 数据类型              (表中添加列)    DROP COLUMN 列名称              (删除表中的列)    MODIFY COLUMN 列名称 数据类型    (修改表中列的数据类型)</code></pre><h3 id="5-SQL-AUTO-INCREMENT-字段："><a href="#5-SQL-AUTO-INCREMENT-字段：" class="headerlink" title="5.SQL AUTO INCREMENT 字段："></a>5.SQL AUTO INCREMENT 字段：</h3><p>会在新记录插入表中时生成一个唯一的数字。<br>我们通常希望在每次插入新记录时，自动地创建主键字段的值。</p><pre><code>列名称 数据类型 AUTO_INCREMENT               (默认 AUTO_INCREMENT 的开始值是 1)ALTER TABLE 表名称 AUTO_INCREMENT=100       (AUTO_INCREMENT 的开始值是 100)</code></pre><h3 id="6-SQL-VIEW（视图）："><a href="#6-SQL-VIEW（视图）：" class="headerlink" title="6.SQL VIEW（视图）："></a>6.SQL VIEW（视图）：</h3><p>视图是基于 SQL 语句的结果集的可视化的表。<br>CREATE VIEW 语法:</p><pre><code>CREATE VIEW [ 视图名称 ] ASSELECT 列名称FROM 表名称WHERE 条件</code></pre><p>CREATE OR REPLACE VIEW(更新视图) 语法:</p><pre><code>CREATE OR REPLACE VIEW [ 视图名称 ] ASSELECT 列名称FROM 表名称WHERE 条件</code></pre><p>撤销视图:</p><pre><code>DROP VIEW view_name [ 视图名称 ]</code></pre><h3 id="7-SQL-Date-函数"><a href="#7-SQL-Date-函数" class="headerlink" title="7.SQL Date 函数:"></a>7.SQL Date 函数:</h3><p>日期。</p><table><thead><tr><th align="center">函数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">NOW()</td><td align="center">返回当前的日期和时间</td></tr><tr><td align="center">CURDATE()</td><td align="center">返回当前的日期</td></tr><tr><td align="center">CURTIME()</td><td align="center">返回当前的时间</td></tr><tr><td align="center">DATE()</td><td align="center">提取日期或日期/时间表达式的日期部分</td></tr><tr><td align="center">EXTRACT()</td><td align="center">返回日期/时间按的单独部分</td></tr><tr><td align="center">DATE_ADD()</td><td align="center">给日期添加指定的时间间隔</td></tr><tr><td align="center">DATE_SUB()</td><td align="center">从日期减去指定的时间间隔</td></tr><tr><td align="center">DATEDIFF()</td><td align="center">返回两个日期之间的天数</td></tr><tr><td align="center">DATE_FORMAT()</td><td align="center">用不同的格式显示日期/时间</td></tr></tbody></table><p>Date 数据类型:<br>MySQL 使用下列数据类型在数据库中存储日期或日期/时间值：</p><ul><li>DATE - 格式 YYYY-MM-DD</li><li>DATETIME - 格式: YYYY-MM-DD HH:MM:SS</li><li>TIMESTAMP - 格式: YYYY-MM-DD HH:MM:SS</li><li>YEAR - 格式 YYYY 或 YY</li></ul><h3 id="8-SQL-NULL-值"><a href="#8-SQL-NULL-值" class="headerlink" title="8.SQL NULL 值:"></a>8.SQL NULL 值:</h3><p>遗漏的未知数据。</p><pre><code>列名称 IS NULL          (带有 NULL 值的记录)列名称 IS NOT NULL      (不带有 NULL 值的记录)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL使用方法 二</title>
      <link href="2020/10/03/SQL%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95-%E4%BA%8C/"/>
      <url>2020/10/03/SQL%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95-%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p>SQL 高级语法教程(MySQL用法) 一</p><h3 id="1-SQL-TOP-子句："><a href="#1-SQL-TOP-子句：" class="headerlink" title="1.SQL TOP 子句："></a>1.SQL TOP 子句：</h3><p>TOP 子句用于规定要返回的记录的数目。</p><pre><code>SELECT TOP 数量|百分比 列名称FROM 表名称</code></pre><p>MySQL 语法:</p><pre><code>SELECT 列名称FROM 表名称LIMIT 起始行, 最多行数 (行数 0 开始 算)</code></pre><h3 id="2-SQL-LIKE-操作符："><a href="#2-SQL-LIKE-操作符：" class="headerlink" title="2.SQL LIKE 操作符："></a>2.SQL LIKE 操作符：</h3><p>LIKE 操作符用于在 WHERE 子句中搜索列中的指定模式。</p><pre><code>SELECT 列名称FROM 表名称WHERE 列名称 LIKE 条件</code></pre><p>“%” 可用于定义通配符（模式中缺少的字母）。</p><pre><code>LIKE &#39;N%&#39;           (以 &quot;N&quot; 开始)LIKE &#39;%g&#39;           (以 &quot;g&quot; 结尾)LIKE &#39;%lon%&#39;        (包含 &quot;lon&quot;)NOT LIKE &#39;%lon%&#39;    (不包含 &quot;lon&quot;)</code></pre><h3 id="3-SQL-通配符："><a href="#3-SQL-通配符：" class="headerlink" title="3.SQL 通配符："></a>3.SQL 通配符：</h3><p>在搜索数据库中的数据时，SQL 通配符可以替代一个或多个字符。<br>PS：SQL 通配符必须与 LIKE 运算符一起使用。</p><table><thead><tr><th align="center">通配符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">%</td><td align="center">替代一个或多个字符</td></tr><tr><td align="center">_</td><td align="center">仅替代一个字符</td></tr><tr><td align="center">[charlist]</td><td align="center">字符列中的任何单一字符</td></tr><tr><td align="center">[^charlist]或者[!charlist]</td><td align="center">不在字符</td></tr></tbody></table><pre><code>[charlist] ：LIKE &#39;[ALN]%&#39;      (以 &quot;A&quot; 或 &quot;L&quot; 或 &quot;N&quot; 开头)[!charlist] ：LIKE &#39;[!ALN]%&#39;    (不以 &quot;A&quot; 或 &quot;L&quot; 或 &quot;N&quot; 开头)</code></pre><h3 id="4-SQL-IN-操作符："><a href="#4-SQL-IN-操作符：" class="headerlink" title="4.SQL IN 操作符："></a>4.SQL IN 操作符：</h3><p>IN 操作符允许我们在 WHERE 子句中规定多个值。</p><pre><code>SELECT 列名称FROM 表名称WHERE 列名称 IN (条件1,条件2,...)</code></pre><h3 id="5-SQL-BETWEEN-操作符："><a href="#5-SQL-BETWEEN-操作符：" class="headerlink" title="5.SQL BETWEEN 操作符："></a>5.SQL BETWEEN 操作符：</h3><p>操作符 BETWEEN … AND 会选取介于两个值之间的数据范围。这些值可以是数值、文本或者日期。</p><pre><code>SELECT 列名称FROM 表名称WHERE 列名称BETWEEN 条件1（包括） AND 条件2（不包括）</code></pre><pre><code>BETWEEN 条件1（包括） AND 条件2（不包括）NOT BETWEEN 条件1（不包括） AND 条件2（包括）</code></pre><h3 id="6-SQL-Alias（别名）："><a href="#6-SQL-Alias（别名）：" class="headerlink" title="6.SQL Alias（别名）："></a>6.SQL Alias（别名）：</h3><p>可以为列名称和表名称指定别名（Alias）。<br>表的别名:</p><pre><code>SELECT 列名称FROM 表名称 AS 别名</code></pre><p>列的别名：</p><pre><code>SELECT 列名称 AS 别名FROM 表名称</code></pre><h3 id="7-SQL-JOIN："><a href="#7-SQL-JOIN：" class="headerlink" title="7.SQL JOIN："></a>7.SQL JOIN：</h3><p>用于根据两个或多个表中的列之间的关系，从这些表中查询数据。<br>不同的 SQL JOIN：</p><ul><li>JOIN: 如果表中有至少一个匹配，则返回行</li><li>LEFT JOIN: 即使右表中没有匹配，也从左表返回所有的行</li><li>RIGHT JOIN: 即使左表中没有匹配，也从右表返回所有的行</li><li>FULL JOIN: 只要其中一个表中存在匹配，就返回行</li></ul><h4 id="1-INNER-JOIN-关键字："><a href="#1-INNER-JOIN-关键字：" class="headerlink" title="1.INNER JOIN 关键字："></a>1.INNER JOIN 关键字：</h4><p>在表中存在至少一个匹配时，INNER JOIN 关键字返回行。</p><pre><code>SELECT 列名称FROM 表1INNER JOIN 表2ON 表1.列=表2.列</code></pre><h4 id="2-LEFT-JOIN-关键字："><a href="#2-LEFT-JOIN-关键字：" class="headerlink" title="2.LEFT JOIN 关键字："></a>2.LEFT JOIN 关键字：</h4><p>LEFT JOIN 关键字会从左表 (表1) 那里返回所有的行，即使在右表 (表2) 中没有匹配的行。</p><pre><code>SELECT 列名称FROM 表1LEFT JOIN 表2ON 表1.列=表2.列</code></pre><h4 id="3-RIGHT-JOIN-关键字："><a href="#3-RIGHT-JOIN-关键字：" class="headerlink" title="3.RIGHT JOIN 关键字："></a>3.RIGHT JOIN 关键字：</h4><p>RIGHT JOIN 关键字会右表 (table_name2) 那里返回所有的行，即使在左表 (table_name1) 中没有匹配的行。</p><pre><code>SELECT 列名称FROM 表1RIGHT JOIN 表2ON 表1.列=表2.列</code></pre><h4 id="4-FULL-JOIN-关键字："><a href="#4-FULL-JOIN-关键字：" class="headerlink" title="4.FULL JOIN 关键字："></a>4.FULL JOIN 关键字：</h4><p>只要其中某个表存在匹配，FULL JOIN 关键字就会返回行。</p><pre><code>SELECT 列名称FROM 表1FULL JOIN 表2ON 表1.列=表2.列</code></pre><h3 id="8-SQL-UNION-和-UNION-ALL-操作符："><a href="#8-SQL-UNION-和-UNION-ALL-操作符：" class="headerlink" title="8.SQL UNION 和 UNION ALL 操作符："></a>8.SQL UNION 和 UNION ALL 操作符：</h3><p>UNION 操作符用于合并两个或多个 SELECT 语句的结果集。<br>UNION 语法：</p><pre><code>SELECT 列名称 FROM 表1UNIONSELECT 列名称 FROM 表2</code></pre><p>UNION ALL 命令和 UNION 命令几乎是等效的，不过 UNION ALL 命令会列出所有的值。<br>UNION ALL 语法：</p><pre><code>SELECT 列名称 FROM 表1UNION ALLSELECT 列名称 FROM 表2</code></pre><h3 id="9-SQL-SELECT-INTO-语句："><a href="#9-SQL-SELECT-INTO-语句：" class="headerlink" title="9.SQL SELECT INTO 语句："></a>9.SQL SELECT INTO 语句：</h3><p>可用于创建表的备份复件。</p><pre><code>SELECT 列名称INTO 新表 [ IN 数据库 ]FROM 老表</code></pre><h3 id="10-SQL-CREATE-DATABASE-语句："><a href="#10-SQL-CREATE-DATABASE-语句：" class="headerlink" title="10.SQL CREATE DATABASE 语句："></a>10.SQL CREATE DATABASE 语句：</h3><p>SQL CREATE DATABASE 语句</p><pre><code>CREATE DATABASE 表名称</code></pre><h3 id="11-CREATE-TABLE-语句："><a href="#11-CREATE-TABLE-语句：" class="headerlink" title="11.CREATE TABLE 语句："></a>11.CREATE TABLE 语句：</h3><p>语句用于创建数据库中的表。</p><pre><code>CREATE TABLE 表名称(列名称1 数据类型,列名称2 数据类型,列名称3 数据类型,....)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL使用方法 一</title>
      <link href="2020/10/02/SQL%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95-%E4%B8%80/"/>
      <url>2020/10/02/SQL%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>SQL 基础语法教程</p><h3 id="1-SQL两个部分-DML-和-DDL："><a href="#1-SQL两个部分-DML-和-DDL：" class="headerlink" title="1.SQL两个部分 DML 和 DDL："></a>1.SQL两个部分 DML 和 DDL：</h3><h4 id="1-数据操作语言-DML-："><a href="#1-数据操作语言-DML-：" class="headerlink" title="1.数据操作语言 (DML)："></a>1.数据操作语言 (DML)：</h4><ul><li>SELECT - 从数据库表中获取数据</li><li>UPDATE - 更新数据库表中的数据</li><li>DELETE - 从数据库表中删除数据</li><li>INSERT INTO - 向数据库表中插入数据</li></ul><h4 id="2-数据定义语言-DDL-："><a href="#2-数据定义语言-DDL-：" class="headerlink" title="2.数据定义语言 (DDL)："></a>2.数据定义语言 (DDL)：</h4><ul><li>CREATE DATABASE - 创建新数据库</li><li>ALTER DATABASE - 修改数据库</li><li>CREATE TABLE - 创建新表</li><li>ALTER TABLE - 变更（改变）数据库表</li><li>DROP TABLE - 删除表</li><li>CREATE INDEX - 创建索引（搜索键）</li><li>DROP INDEX - 删除索引</li></ul><h3 id="2-SQL语句："><a href="#2-SQL语句：" class="headerlink" title="2.SQL语句："></a>2.SQL语句：</h3><h4 id="1-SQL-SELECT-语句："><a href="#1-SQL-SELECT-语句：" class="headerlink" title="1.SQL SELECT 语句："></a>1.SQL SELECT 语句：</h4><p>SELECT 语句用于从表中选取数据。</p><pre><code>    SELECT 列名称 FROM 表名称 (单列查询)或者：    SELECT * FROM 表名称 (全列查询)或者：    SELECT LastName,FirstName FROM Persons (查询名为 &quot;LastName&quot; 和 &quot;FirstName&quot; 的列的内容)</code></pre><h4 id="2-SQL-SELECT-DISTINCT-语句："><a href="#2-SQL-SELECT-DISTINCT-语句：" class="headerlink" title="2.SQL SELECT DISTINCT 语句："></a>2.SQL SELECT DISTINCT 语句：</h4><p>在表中，可能会包含重复值。这并不成问题，不过，有时您也许希望仅仅列出不同（distinct）的值。</p><pre><code>SELECT DISTINCT 列名称 FROM 表名称</code></pre><h4 id="3-SQL-WHERE-子句："><a href="#3-SQL-WHERE-子句：" class="headerlink" title="3.SQL WHERE 子句："></a>3.SQL WHERE 子句：</h4><p>如需有条件地从表中选取数据，可将 WHERE 子句添加到 SELECT 语句。</p><pre><code>SELECT 列名称 FROM 表名称 WHERE 列名称 运算符 值</code></pre><table><thead><tr><th align="center">操作符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">=</td><td align="center">等于</td></tr><tr><td align="center">&lt;&gt;</td><td align="center">不等于</td></tr><tr><td align="center">&gt;</td><td align="center">大于</td></tr><tr><td align="center">&lt;</td><td align="center">小于</td></tr><tr><td align="center">&gt;=</td><td align="center">大于等于</td></tr><tr><td align="center">&lt;=</td><td align="center">小于等于</td></tr><tr><td align="center">BETWEEN</td><td align="center">在某个范围内</td></tr><tr><td align="center">LIKE</td><td align="center">搜索某种模式</td></tr></tbody></table><p><strong>PS</strong>: SQL使用单引号来环绕<strong>文本值</strong>（大部分数据库系统也接受双引号）。如果是<strong>数值</strong>，请不要使用引号。</p><h4 id="4-SQL-AND-amp-OR-运算符："><a href="#4-SQL-AND-amp-OR-运算符：" class="headerlink" title="4.SQL AND &amp; OR 运算符："></a>4.SQL AND &amp; OR 运算符：</h4><p>AND 和 OR 可在 WHERE 子语句中把两个或多个条件结合起来。</p><ol><li>如果第一个条件和第二个条件都成立，则 AND 运算符显示一条记录。</li><li>如果第一个条件和第二个条件中只要有一个成立，则 OR 运算符显示一条记录。</li></ol><pre><code>AND：SELECT 列名称 FROM 表名称 WHERE 条件 AND 条件OR ：SELECT 列名称 FROM 表名称 WHERE 条件 OR  条件</code></pre><h4 id="5-SQL-ORDER-BY-子句："><a href="#5-SQL-ORDER-BY-子句：" class="headerlink" title="5.SQL ORDER BY 子句："></a>5.SQL ORDER BY 子句：</h4><p>ORDER BY 语句用于根据指定的列对结果集进行排序。<br>ORDER BY 语句默认按照升序对记录进行排序，降序对记录进行排序，可以使用 DESC 关键字。</p><pre><code>SELECT 列名称 FROM 表名称 ORDER BY 列名称 (升序)SELECT 列名称 FROM 表名称 ORDER BY 列名称 DESC (降序)</code></pre><h4 id="6-SQL-INSERT-INTO-语句："><a href="#6-SQL-INSERT-INTO-语句：" class="headerlink" title="6.SQL INSERT INTO 语句："></a>6.SQL INSERT INTO 语句：</h4><p>INSERT INTO 语句用于向表格中插入新的行。</p><pre><code>    INSERT INTO 表名称 VALUES (值1, 值2,....)                (插入新的行)或者：    INSERT INTO 表名称 (列1, 列2,...) VALUES (值1, 值2,....)  (指定列插入数据)</code></pre><h4 id="7-SQL-UPDATE-语句："><a href="#7-SQL-UPDATE-语句：" class="headerlink" title="7.SQL UPDATE 语句："></a>7.SQL UPDATE 语句：</h4><p>Update 语句用于修改表中的数据。</p><pre><code>UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值</code></pre><h4 id="8-SQL-DELETE-语句："><a href="#8-SQL-DELETE-语句：" class="headerlink" title="8.SQL DELETE 语句："></a>8.SQL DELETE 语句：</h4><p>DELETE 语句用于删除表中的行。</p><pre><code>    DELETE FROM 表名称 WHERE 列名称 = 值  (删除某行)或者：    DELETE * FROM 表名称                 (删除所有行)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL安装</title>
      <link href="2020/10/01/MySQL%E5%AE%89%E8%A3%85/"/>
      <url>2020/10/01/MySQL%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>MySQL的安装教程</p><h3 id="1-MySQL的简单介绍："><a href="#1-MySQL的简单介绍：" class="headerlink" title="1.MySQL的简单介绍："></a>1.MySQL的简单介绍：</h3><p>MySQL关是一种关系数据库管理系统，所使用的 SQL 语言是用于访问数据库的最常用的标准化语言，其特点为体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，在 Web应用方面 MySQL 是最好的 RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。</p><h3 id="2-MySQL安装教学"><a href="#2-MySQL安装教学" class="headerlink" title="2.MySQL安装教学:"></a>2.MySQL安装教学:</h3><h4 id="1-下载MySQL："><a href="#1-下载MySQL：" class="headerlink" title="1.下载MySQL："></a>1.下载MySQL：</h4><p>MySQL官网：<a href="https://www.mysql.com/">https://www.mysql.com</a>  </p><ol><li>点击 <strong>downloads</strong>。</li><li>滑到下面点击 <strong>MySQL Community (GPL) Downloads »</strong>。</li><li>再点击 <strong>MySQL Community Server</strong>。</li><li>选择这个版本进行下载 <strong>Windows (x86, 64-bit), ZIP Archive</strong>（免安装版）。</li></ol><h4 id="2-安装MySQL："><a href="#2-安装MySQL：" class="headerlink" title="2.安装MySQL："></a>2.安装MySQL：</h4><h5 id="1-解压下载好的文件（解压到哪里看你自己）。"><a href="#1-解压下载好的文件（解压到哪里看你自己）。" class="headerlink" title="1.解压下载好的文件（解压到哪里看你自己）。"></a>1.解压下载好的文件（解压到哪里看你自己）。</h5><p>PS：**<em>注意，安装的目录应当放在指定位置，绝对路径中避免出现中文，**</em></p><h5 id="2-以管理员启动命令行。"><a href="#2-以管理员启动命令行。" class="headerlink" title="2.以管理员启动命令行。"></a>2.以管理员启动命令行。</h5><h5 id="3-命令行窗口移动到你解压的MySQL文件下bin内："><a href="#3-命令行窗口移动到你解压的MySQL文件下bin内：" class="headerlink" title="3.命令行窗口移动到你解压的MySQL文件下bin内："></a>3.命令行窗口移动到你解压的MySQL文件下bin内：</h5><pre><code>cd ../..X:  cd XXXXXX （D:\ruanjian\MySQL\mysql-8.0.21-winx64\bin）</code></pre><p>(X代表你MySQL解压的盘, XXXXXX代表你放的路径)</p><h5 id="4-安装MySQL的服务："><a href="#4-安装MySQL的服务：" class="headerlink" title="4.安装MySQL的服务："></a>4.安装MySQL的服务：</h5><pre><code>mysqld --install</code></pre><p>Service successfully installed.(安装成功提示)。</p><h5 id="5-初始化MySQL："><a href="#5-初始化MySQL：" class="headerlink" title="5.初始化MySQL："></a>5.初始化MySQL：</h5><pre><code>mysqld --initialize --console</code></pre><p>PS：记住 root@localhost: 后面 初始化生成的随机密码</p><pre><code>2020-10-01T09:08:10.996523Z 6 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: ( &lt;flatW0fKlzB )&lt;-这个</code></pre><h5 id="6-开启MySQL服务："><a href="#6-开启MySQL服务：" class="headerlink" title="6.开启MySQL服务："></a>6.开启MySQL服务：</h5><pre><code>net start mysql</code></pre><h5 id="7-登录验证是否安装成功："><a href="#7-登录验证是否安装成功：" class="headerlink" title="7.登录验证是否安装成功："></a>7.登录验证是否安装成功：</h5><pre><code>mysql -u root -p</code></pre><p>然后输入刚刚获得的随机密码。</p><pre><code>Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 10Server version: 8.0.21Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.</code></pre><p>说明你的mysql已经安装成功！注意，，一定要先开启服务，不然会登陆失败，出现拒绝访问的提示符！！！</p><h5 id="8-修改密码："><a href="#8-修改密码：" class="headerlink" title="8.修改密码："></a>8.修改密码：</h5><pre><code>alter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;root&#39;;(by 接着的是密码)</code></pre><h5 id="9-设置环境变量："><a href="#9-设置环境变量：" class="headerlink" title="9.设置环境变量："></a>9.设置环境变量：</h5><ol><li>点击”我的电脑”–&gt;”属性”–&gt;’’高级系统设置’’–&gt;’’环境变量’’</li><li>点击”系统变量的新建”</li></ol><pre><code>变量名：mysql变量值：（安装路径）</code></pre><ol start="3"><li>添加进入Path：</li></ol><p>点击新建</p><pre><code>%mysql%bin</code></pre><ol start="4"><li>在mysql目录下创建一个 my.ini 配置文件:</li></ol><pre><code>[mysqld]character-set-server=utf8bind-address = 0.0.0.0port = 3306default-storage-engine=INNODB[mysql]default-character-set=utf8[mysql.server]default-character-set=utf8[mysql_safe]default-character-set=utf8[client]default-character-set=utf8</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大排序算法——Java语言实现</title>
      <link href="2020/09/30/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94Java%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/"/>
      <url>2020/09/30/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94Java%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>十大排序算法——Java语言版</p><h3 id="1-冒泡排序（Bubble-Sort）"><a href="#1-冒泡排序（Bubble-Sort）" class="headerlink" title="1.冒泡排序（Bubble Sort）"></a>1.冒泡排序（Bubble Sort）</h3><pre><code>public static void bubble_sort(int[] arr, int len) &#123;    int i, j, temp;    for (i = 0; i &lt; len - 1; i++)        for (j = 0; j &lt; len - 1 - i; j++)            if (arr[j] &gt; arr[j + 1]) &#123;                temp = arr[j];                arr[j] = arr[j + 1];                arr[j + 1] = temp;            &#125;&#125;</code></pre><ul><li>arr[]：需要排序的数组。</li><li>len：数组长度。</li></ul><h3 id="2-选择排序（Selection-Sort）"><a href="#2-选择排序（Selection-Sort）" class="headerlink" title="2.选择排序（Selection Sort）"></a>2.选择排序（Selection Sort）</h3><pre><code>public static void selection_sort(int[] arr, int len) &#123;    int i, j, temp;    for (i = 0 ; i &lt; len - 1 ; i++) &#123;        int min = i;        for (j = i + 1; j &lt; len; j++) &#123;            if (arr[j] &lt; arr[min])                min = j;        &#125;        temp = arr[min];        arr[min] = arr[i];        arr[i] = temp;    &#125;&#125;</code></pre><ul><li>arr[]：需要排序的数组。</li><li>len：数组长度。</li></ul><h3 id="3-插入排序（Insertion-Sort）"><a href="#3-插入排序（Insertion-Sort）" class="headerlink" title="3.插入排序（Insertion Sort）"></a>3.插入排序（Insertion Sort）</h3><pre><code>public static void insertion_sort(int[] arr, int len) &#123;    int i, j, key;    for (i = 1; i &lt; len; i++) &#123;        key = arr[i];        j = i - 1;        while((j &gt;= 0) &amp;&amp; (arr[j] &gt; key)) &#123;            arr[j + 1] = arr[j];            j--;        &#125;        arr[j + 1] = key;    &#125;&#125;</code></pre><ul><li>arr[]：需要排序的数组。</li><li>len：数组长度。</li></ul><h3 id="4-希尔排序（Shell-Sort）"><a href="#4-希尔排序（Shell-Sort）" class="headerlink" title="4.希尔排序（Shell Sort）"></a>4.希尔排序（Shell Sort）</h3><pre><code>public static void shell_sort(int[] arr, int len) &#123;    int gap, i, j;    int temp;    for (gap = len &gt;&gt; 1; gap &gt; 0; gap &gt;&gt;= 1)        for (i = gap; i &lt; len; i++) &#123;            temp = arr[i];            for (j = i - gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j -= gap)                arr[j + gap] = arr[j];            arr[j + gap] = temp;        &#125;&#125;</code></pre><ul><li>arr[]：需要排序的数组。</li><li>len：数组长度。</li><li>*&gt;&gt;*：右移一位（二进制） 如： 00001010（10） &gt;&gt; 等于 00000101（5） 这里是除2的作用。</li></ul><h3 id="5-归并排序（Merge-Sort）"><a href="#5-归并排序（Merge-Sort）" class="headerlink" title="5.归并排序（Merge Sort）"></a>5.归并排序（Merge Sort）</h3><pre><code>public static void merge_sort(int[] arr, int start, int end) &#123;    if(start &lt; end) &#123;        int mid = (start + end) / 2;        merge_sort(arr, start, mid);        merge_sort(arr, mid + 1, end);        merge(arr, start, mid, end);    &#125;&#125;public static void merge(int[] arr, int start, int mid, int end) &#123;    int[] temp = new int[end - start + 1];    int l = start, r = mid + 1, j = 0;    while (l &lt;= mid &amp;&amp; r &lt;= end) &#123;        if(arr[l] &lt; arr[r]) &#123;            temp[j++] = arr[l++];        &#125;else&#123;            temp[j++] = arr[r++];        &#125;    &#125;    while (l &lt;= mid) &#123;        temp[j++] = arr[l++];    &#125;    while (r &lt;= end) &#123;        temp[j++] = arr[r++];    &#125;    for (int i = 0; i &lt; temp.length; i++) &#123;        arr[i + start] = temp[i];    &#125;&#125;</code></pre><ul><li>*arr：需要排序数组的地址。</li><li>start：开始下标。</li><li>mid：中间下标。</li><li>end：结束下标。</li></ul><h3 id="6-快速排序（Quick-Sort）"><a href="#6-快速排序（Quick-Sort）" class="headerlink" title="6.快速排序（Quick Sort）"></a>6.快速排序（Quick Sort）</h3><pre><code>public static void quick_sort(int arr[], int start, int end) &#123;    if (start &lt; end) &#123;        int index = partition(arr, start, end);        quick_sort(arr, start, index - 1);        quick_sort(arr, index + 1, end);    &#125;&#125;public static int partition(int arr[], int start, int end) &#123;    int temp = arr[start];    int li = start, ri = end;    while (li &lt; ri) &#123;        while (li &lt; ri &amp;&amp; arr[ri] &gt; temp)            ri--;        if (li &lt; ri) &#123;            arr[li] = arr[ri];            li++;        &#125;        while (li &lt; ri &amp;&amp; arr[li] &lt; temp)            li++;        if (li &lt; ri) &#123;            arr[ri] = arr[li];            ri--;        &#125;    &#125;    arr[li] = temp;    return li;&#125;</code></pre><ul><li>arr[]：需要排序的数组。</li><li>start：开始下标。</li><li>index：中间下标。</li><li>end：结束下标。</li></ul><h3 id="7-堆排序（Heap-Sort）"><a href="#7-堆排序（Heap-Sort）" class="headerlink" title="7.堆排序（Heap Sort）"></a>7.堆排序（Heap Sort）</h3><pre><code>public static void heap_sort(int arr[], int len) &#123;    for(int i = len; i &gt; 1; i --) &#123;        heap(arr, i);    &#125;&#125;public static void heap(int arr[], int len) &#123;    int dad = len / 2 - 1, son = 2 * dad + 1, temp;    while (dad &gt;= 0) &#123;        if (son + 1 &lt;= len - 1 &amp;&amp; arr[son] &lt; arr[son + 1])            son++;        if (arr[dad] &lt; arr[son]) &#123;            temp = arr[dad];            arr[dad] = arr[son];            arr[son] = temp;        &#125;        dad--;        son = 2 * dad + 1;    &#125;    temp = arr[0];    arr[0] = arr[len - 1];    arr[len - 1] = temp;&#125;</code></pre><ul><li>arr[]：需要排序的数组。</li><li>len：数组长度。</li><li>dad：最后一个父节点。</li><li>son：该父节点下的首个子节点。</li><li>if (son + 1 &lt;= len - 1 &amp;&amp; arr[son] &lt; arr[son + 1])：判断是否有两个子节点若有则在其中寻找最大子节点。</li></ul><h3 id="8-计数排序（Counting-Sort）"><a href="#8-计数排序（Counting-Sort）" class="headerlink" title="8.计数排序（Counting Sort）"></a>8.计数排序（Counting Sort）</h3><pre><code>public static void counting_Sort(int arr[], int len) &#123;    int max = arr[0], min = arr[0], i, j = 0;    for (i = 0; i &lt; len; i++) &#123;        if (arr[i] &lt; min)            min = arr[i];        if (arr[i] &gt; max)            max = arr[i];    &#125;    int new_len = max - min + 1;    int[] conunting_arr = new int[new_len];    for (i = 0; i &lt; new_len; i++) &#123;        conunting_arr[i] = 0;    &#125;    for (i = 0; i &lt; len; i++) &#123;        conunting_arr[arr[i] - min]++;    &#125;    for (i = 0; i &lt; new_len; i++) &#123;        int index = conunting_arr[i];        while (index != 0) &#123;            arr[j] = i + min;            index--;            j++;        &#125;    &#125;&#125;</code></pre><ul><li>arr[]：需要排序的数组。</li><li>len：数组长度。</li><li>conunting_arr：计数数组。</li><li>new_len：计数数组长度。</li></ul><h3 id="9-桶排序（Bucket-Sort）"><a href="#9-桶排序（Bucket-Sort）" class="headerlink" title="9.桶排序（Bucket Sort）"></a>9.桶排序（Bucket Sort）</h3><pre><code>public static void bucket_sort(int arr[], int len) &#123;    int max = 0, j = 0;    for (int i = 0; i &lt; len; i++) &#123;        if (arr[i] &gt; max)            max = arr[i];    &#125;    max += 1;    int[] bucket = new int[max];    for (int i = 0; i &lt; len; i++)        bucket[arr[i]]++;    for (int i = 0; i &lt; max; i++)        while ((bucket[i]--) &gt; 0)            arr[j++] = i;&#125;</code></pre><ul><li>arr[]：需要排序的数组。</li><li>len：数组长度。</li><li>int* bucket = (int*)malloc(sizeof(int) * max)：动态开辟桶数量。</li><li>12~13行：遍历数组,将元素放到对应桶中。</li><li>14~16行：把桶内元素放回数组中。</li></ul><h3 id="10-基数排序（Radix-Sort）"><a href="#10-基数排序（Radix-Sort）" class="headerlink" title="10.基数排序（Radix Sort）"></a>10.基数排序（Radix Sort）</h3><pre><code>public static void radix_sort(int arr[], int len) &#123;    int level = 0;    int max = arr[0], i;    for (i = 0; i &lt; len; i++) &#123;        if (arr[i] &gt; max)            max = arr[i];    &#125;    for (i = max; i &gt; 0; i /= 10) &#123;        level++;    &#125;    for (i = 0; i &lt; level; i++) &#123;        radix(arr, len, i);    &#125;&#125;public static void radix(int arr[], int len, int level) &#123;    int[] bucket =new int[10];    int[] temp = new int[len];    int i, j;    int flag = (int)Math.pow(10, level);    for (i = 0; i &lt; len; i++) &#123;        bucket[arr[i] / flag % 10]++;    &#125;    bucket[0]--;    for (i = 1; i &lt; 10; i++) &#123;        bucket[i] += bucket[i - 1];    &#125;    for (i = len - 1; i &gt;= 0; i--) &#123;        temp[bucket[arr[i] / flag % 10]] = arr[i];        bucket[arr[i] / flag % 10]--;    &#125;    for (i = 0; i &lt; len; i++) &#123;        arr[i] = temp[i];    &#125;&#125;</code></pre><ul><li>arr[]：需要排序的数组。</li><li>len：数组长度。</li><li>bucket：排序桶。</li><li>temp：临时数组。</li></ul><h3 id="PS"><a href="#PS" class="headerlink" title="PS:"></a>PS:</h3><h4 id="1-动态大小数组："><a href="#1-动态大小数组：" class="headerlink" title="1.动态大小数组："></a>1.动态大小数组：</h4><pre><code>int[] arr = new int[len];</code></pre><h4 id="2-获取数组长度："><a href="#2-获取数组长度：" class="headerlink" title="2.获取数组长度："></a>2.获取数组长度：</h4><pre><code>int len = arr.length;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大排序算法——C语言实现</title>
      <link href="2020/09/29/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/"/>
      <url>2020/09/29/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>十大排序算法——C语言版</p><h3 id="1-冒泡排序（Bubble-Sort）"><a href="#1-冒泡排序（Bubble-Sort）" class="headerlink" title="1.冒泡排序（Bubble Sort）"></a>1.冒泡排序（Bubble Sort）</h3><pre><code>void bubble_sort(int arr[], int len)&#123;    int i, j, temp;    for (i = 0; i &lt; len - 1; i++)        for (j = 0; j &lt; len - 1 - i; j++)            if (arr[j] &gt; arr[j + 1])            &#123;                temp = arr[j];                arr[j] = arr[j + 1];                arr[j + 1] = temp;            &#125;&#125;</code></pre><ul><li>arr[]：需要排序的数组。</li><li>len：数组长度。</li></ul><h3 id="2-选择排序（Selection-Sort）"><a href="#2-选择排序（Selection-Sort）" class="headerlink" title="2.选择排序（Selection Sort）"></a>2.选择排序（Selection Sort）</h3><pre><code>void selection_sort(int arr[], int len)&#123;    int i,j;    for (i = 0 ; i &lt; len - 1 ; i++)    &#123;        int min = i;        for (j = i + 1; j &lt; len; j++)        &#123;            if (arr[j] &lt; arr[min])                min = j;        &#125;            swap(&amp;arr[min], &amp;arr[i]);    &#125;&#125;</code></pre><ul><li>arr[]：需要排序的数组。</li><li>len：数组长度。</li><li>swap：交换函数。</li></ul><pre><code>void swap(int *a, int *b)&#123;    int temp = *a;    *a = *b;    *b = temp;&#125;</code></pre><h3 id="3-插入排序（Insertion-Sort）"><a href="#3-插入排序（Insertion-Sort）" class="headerlink" title="3.插入排序（Insertion Sort）"></a>3.插入排序（Insertion Sort）</h3><pre><code>void insertion_sort(int arr[], int len)&#123;    int i, j, key;    for (i = 1; i &lt; len; i++)    &#123;        key = arr[i];        j = i - 1;        while((j &gt;= 0) &amp;&amp; (arr[j] &gt; key))        &#123;            arr[j + 1] = arr[j];            j--;        &#125;        arr[j + 1] = key;    &#125;&#125;</code></pre><ul><li>arr[]：需要排序的数组。</li><li>len：数组长度。</li></ul><h3 id="4-希尔排序（Shell-Sort）"><a href="#4-希尔排序（Shell-Sort）" class="headerlink" title="4.希尔排序（Shell Sort）"></a>4.希尔排序（Shell Sort）</h3><pre><code>void shell_sort(int arr[], int len)&#123;    int gap, i, j;    int temp;    for (gap = len &gt;&gt; 1; gap &gt; 0; gap &gt;&gt;= 1)        for (i = gap; i &lt; len; i++)        &#123;            temp = arr[i];            for (j = i - gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j -= gap)                arr[j + gap] = arr[j];            arr[j + gap] = temp;        &#125;&#125;</code></pre><ul><li>arr[]：需要排序的数组。</li><li>len：数组长度。</li><li>*&gt;&gt;*：右移一位（二进制） 如： 00001010（10） &gt;&gt; 等于 00000101（5） 这里是除2的作用。</li></ul><h3 id="5-归并排序（Merge-Sort）"><a href="#5-归并排序（Merge-Sort）" class="headerlink" title="5.归并排序（Merge Sort）"></a>5.归并排序（Merge Sort）</h3><pre><code>void merge_sort(int* arr, int start, int end)&#123;    if(start &lt; end)    &#123;        int mid = (start + end) / 2;        merge_sort(arr, start, mid);        merge_sort(arr, mid + 1, end);        merge(arr, start, mid, end);    &#125;&#125;void merge(int* arr, int start, int mid, int end)&#123;    int len_l, len_r;    len_l = mid - start + 1;    len_r = end - mid;    int* l = (int*)malloc(sizeof(int) * len_l);    int* r = (int*)malloc(sizeof(int) * len_r);    memcpy(l, arr + start, sizeof(int) * len_l);    memcpy(r, arr + mid + 1, sizeof(int) * len_r);    int i = 0, j = 0, k = start;    while(i &lt; len_l &amp;&amp; j &lt; len_r)    &#123;        arr[k++] = l[i] &lt; r[j] ? l[i++] : r[j++];    &#125;    while(i &lt; len_l)    &#123;        arr[k++] = l[i++];    &#125;&#125;</code></pre><ul><li>*arr：需要排序数组的地址。</li><li>start：开始下标。</li><li>mid：中间下标。</li><li>end：结束下标。</li><li>memcpy：</li></ul><pre><code>void * memcpy ( void * destination, const void * source, size_t num );</code></pre><p>将source指向的地址处的 num 个 <strong>字节</strong> 拷贝到 destination 指向的地址处。注意加黑的字，是字节。</p><pre><code>例子：    int a[10] = &#123;0,1,2,3,4,5,6,7,8,9&#125;;    memcpy(a, a + 3, sizeof(int) * 2);结果：    3,4,2,3,4,5,6,7,8,9</code></pre><ul><li>malloc：</li></ul><pre><code>void *malloc(size_t size)</code></pre><p>动态分配内存。</p><pre><code>变量定义数组大小：    int* l = (int*)malloc(sizeof(int) * len_l);等于     l(len);</code></pre><h3 id="6-快速排序（Quick-Sort）"><a href="#6-快速排序（Quick-Sort）" class="headerlink" title="6.快速排序（Quick Sort）"></a>6.快速排序（Quick Sort）</h3><pre><code>void quick_sort(int arr[], int start, int end)&#123;    if (start &lt; end)    &#123;        int index = partition(arr, start, end);        quick_sort(arr, start, index - 1);        quick_sort(arr, index + 1, end);    &#125;&#125;int partition(int arr[], int start, int end)&#123;    int temp = arr[start];    int li = start, ri = end;    while (li &lt; ri)    &#123;        while (li &lt; ri &amp;&amp; arr[ri] &gt; temp)            ri--;        if (li &lt; ri)        &#123;            arr[li] = arr[ri];            li++;        &#125;        while (li &lt; ri &amp;&amp; arr[li] &lt; temp)            li++;        if (li &lt; ri)        &#123;            arr[ri] = arr[li];            ri--;        &#125;    &#125;    arr[li] = temp;    return li;&#125;</code></pre><ul><li>arr[]：需要排序的数组。</li><li>start：开始下标。</li><li>index：中间下标。</li><li>end：结束下标。</li></ul><h3 id="7-堆排序（Heap-Sort）"><a href="#7-堆排序（Heap-Sort）" class="headerlink" title="7.堆排序（Heap Sort）"></a>7.堆排序（Heap Sort）</h3><pre><code>void heap_sort(int arr[], int len)&#123;    for(int i = len; i &gt; 1; i --)    &#123;        heap(arr, i);    &#125;&#125;void heap(int arr[], int len)&#123;    int dad = len / 2 - 1;    int son = 2 * dad + 1;    while (dad &gt;= 0)    &#123;        if (son + 1 &lt;= len - 1 &amp;&amp; arr[son] &lt; arr[son + 1])            son++;        if (arr[dad] &lt; arr[son])            swap(&amp;arr[dad], &amp;arr[son]);        dad--;        son = 2 * dad + 1;    &#125;    swap(&amp;arr[0], &amp;arr[len - 1]);&#125;</code></pre><ul><li>arr[]：需要排序的数组。</li><li>len：数组长度。</li><li>dad：最后一个父节点。</li><li>son：该父节点下的首个子节点。</li><li>if (son + 1 &lt;= len - 1 &amp;&amp; arr[son] &lt; arr[son + 1])：判断是否有两个子节点若有则在其中寻找最大子节点。</li><li>swap：交换函数。</li></ul><pre><code>void swap(int *a, int *b)&#123;    int temp = *a;    *a = *b;    *b = temp;&#125;</code></pre><h3 id="8-计数排序（Counting-Sort）"><a href="#8-计数排序（Counting-Sort）" class="headerlink" title="8.计数排序（Counting Sort）"></a>8.计数排序（Counting Sort）</h3><pre><code>void counting_Sort(int arr[], int len)&#123;    int max = arr[0], min = arr[0], i, j = 0;    for (i = 0; i &lt; len; i++)    &#123;        if (arr[i] &lt; min)            min = arr[i];        if (arr[i] &gt; max)            max = arr[i];    &#125;    int new_len = max - min + 1;    int* conunting_arr = (int*)malloc(sizeof(int) * new_len);    for (i = 0; i &lt; new_len; i++)    &#123;        conunting_arr[i] = 0;    &#125;    for (i = 0; i &lt; len; i++)    &#123;        conunting_arr[arr[i] - min]++;    &#125;    for (i = 0; i &lt; new_len; i++)    &#123;        int index = conunting_arr[i];        while (index != 0)        &#123;            arr[j] = i + min;            index--;            j++;        &#125;    &#125;&#125;</code></pre><ul><li>arr[]：需要排序的数组。</li><li>len：数组长度。</li><li>int* conunting_arr = (int*)malloc(sizeof(int) * new_len)：计数数组。</li><li>new_len：计数数组长度。</li></ul><h3 id="9-桶排序（Bucket-Sort）"><a href="#9-桶排序（Bucket-Sort）" class="headerlink" title="9.桶排序（Bucket Sort）"></a>9.桶排序（Bucket Sort）</h3><pre><code>void bucket_sort(int arr[], int len) &#123;    int max = 0, j = 0;    for (int i = 0; i &lt; len; i++)    &#123;        if (arr[i] &gt; max)            max = arr[i];    &#125;    max += 1;    int* bucket = (int*)malloc(sizeof(int) * max);    memset(bucket, 0, sizeof(int) * max);    for (int i = 0; i &lt; len; i++)        bucket[arr[i]]++;    for (int i = 0; i &lt; max; i++)        while ((bucket[i]--) &gt; 0)            arr[j++] = i;&#125;</code></pre><ul><li>arr[]：需要排序的数组。</li><li>len：数组长度。</li><li>int* bucket = (int*)malloc(sizeof(int) * max)：动态开辟桶数量。</li><li>12~13行：遍历数组,将元素放到对应桶中。</li><li>14~16行：把桶内元素放回数组中。</li></ul><h3 id="10-基数排序（Radix-Sort）"><a href="#10-基数排序（Radix-Sort）" class="headerlink" title="10.基数排序（Radix Sort）"></a>10.基数排序（Radix Sort）</h3><pre><code>void radix_sort(int arr[], int len)&#123;    int level = 0;    int max = arr[0], i;    for (i = 0; i &lt; len; i++)    &#123;        if (arr[i] &gt; max)            max = arr[i];    &#125;    for (i = max; i &gt; 0; i /= 10)    &#123;        level++;    &#125;    for (i = 0; i &lt; level; i++)    &#123;        radix(arr, len, i);    &#125;&#125;void radix(int arr[], int len, int level)&#123;    int bucket[10] = &#123;0&#125;;    int* temp = (int*)malloc(sizeof(int) * len);    int i, j;    int flag = pow(10, level);    for (i = 0; i &lt; len; i++)    &#123;        bucket[arr[i] / flag % 10]++;    &#125;    bucket[0]--;    for (i = 1; i &lt; 10; i++)    &#123;        bucket[i] += bucket[i - 1];    &#125;    for (i = len - 1; i &gt;= 0; i--)    &#123;        temp[bucket[arr[i] / flag % 10]] = arr[i];        bucket[arr[i] / flag % 10]--;    &#125;    for (i = 0; i &lt; len; i++)    &#123;        arr[i] = temp[i];    &#125;&#125;</code></pre><ul><li>arr[]：需要排序的数组。</li><li>len：数组长度。</li><li>bucket：排序桶。</li><li>temp：临时数组。</li></ul><h3 id="PS"><a href="#PS" class="headerlink" title="PS:"></a>PS:</h3><h4 id="1-动态大小数组："><a href="#1-动态大小数组：" class="headerlink" title="1.动态大小数组："></a>1.动态大小数组：</h4><pre><code>int* arr = (int*)malloc(sizeof(int) * len);</code></pre><h4 id="2-获取数组长度："><a href="#2-获取数组长度：" class="headerlink" title="2.获取数组长度："></a>2.获取数组长度：</h4><pre><code>int len = (int)sizeof(arr) / sizeof(*arr);</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大经典排序算法</title>
      <link href="2020/09/27/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>2020/09/27/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>十大排序算法概念</p><h3 id="1-算法描述："><a href="#1-算法描述：" class="headerlink" title="1.算法描述："></a>1.算法描述：</h3><h4 id="1-算法分类："><a href="#1-算法分类：" class="headerlink" title="1.算法分类："></a>1.算法分类：</h4><p>十种常见排序算法可以分为两大类：</p><ul><li><strong>比较类排序</strong>：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破 O(nlogn) ，因此也称为非线性时间比较类排序。</li><li><strong>非比较类排序</strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。</li></ul><img src="https://jellyrain.gitee.io/jellyrain-image/849589-20190306165258970-1789860540.png" width="50%" height="50%"><h4 id="2-算法复杂度"><a href="#2-算法复杂度" class="headerlink" title="2.算法复杂度:"></a>2.算法复杂度:</h4><img src="https://jellyrain.gitee.io/jellyrain-image/849589-20180402133438219-1946132192.png" width="50%" height="50%"><h4 id="3-相关概念"><a href="#3-相关概念" class="headerlink" title="3.相关概念:"></a>3.相关概念:</h4><ul><li><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</li><li><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</li><li><strong>时间复杂度</strong>：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</li><li><strong>空间复杂度</strong>：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。</li></ul><h3 id="2-排序算法："><a href="#2-排序算法：" class="headerlink" title="2.排序算法："></a>2.排序算法：</h3><h4 id="1-冒泡排序（Bubble-Sort）"><a href="#1-冒泡排序（Bubble-Sort）" class="headerlink" title="1.冒泡排序（Bubble Sort）"></a>1.冒泡排序（Bubble Sort）</h4><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 </p><h5 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h5><ul><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ul><h5 id="2-动图演示"><a href="#2-动图演示" class="headerlink" title="2.动图演示"></a>2.动图演示</h5><img src="https://jellyrain.gitee.io/jellyrain-image/849589-20171015223238449-2146169197.gif" width="50%" height="50%"><h4 id="2-选择排序（Selection-Sort）"><a href="#2-选择排序（Selection-Sort）" class="headerlink" title="2.选择排序（Selection Sort）"></a>2.选择排序（Selection Sort）</h4><p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p><h5 id="1-算法描述-1"><a href="#1-算法描述-1" class="headerlink" title="1.算法描述"></a>1.算法描述</h5><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p><ul><li>初始状态：无序区为R[1..n]，有序区为空；</li><li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>n-1趟结束，数组有序化了。</li></ul><h5 id="2-动图演示-1"><a href="#2-动图演示-1" class="headerlink" title="2.动图演示"></a>2.动图演示</h5><img src="https://jellyrain.gitee.io/jellyrain-image/849589-20171015224719590-1433219824.gif" width="50%" height="50%"><h5 id="3-算法分析"><a href="#3-算法分析" class="headerlink" title="3.算法分析"></a>3.算法分析</h5><p>表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。</p><h4 id="3-插入排序（Insertion-Sort）"><a href="#3-插入排序（Insertion-Sort）" class="headerlink" title="3.插入排序（Insertion Sort）"></a>3.插入排序（Insertion Sort）</h4><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><h5 id="1-算法描述-2"><a href="#1-算法描述-2" class="headerlink" title="1.算法描述"></a>1.算法描述</h5><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ul><h5 id="2-动图演示-2"><a href="#2-动图演示-2" class="headerlink" title="2.动图演示"></a>2.动图演示</h5><img src="https://jellyrain.gitee.io/jellyrain-image/849589-20171015225645277-1151100000.gif" width="50%" height="50%"><h5 id="3-算法分析-1"><a href="#3-算法分析-1" class="headerlink" title="3.算法分析"></a>3.算法分析</h5><p>插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><h4 id="4-希尔排序（Shell-Sort）"><a href="#4-希尔排序（Shell-Sort）" class="headerlink" title="4.希尔排序（Shell Sort）"></a>4.希尔排序（Shell Sort）</h4><p>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。</p><h5 id="1-算法描述-3"><a href="#1-算法描述-3" class="headerlink" title="1.算法描述"></a>1.算法描述</h5><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><ul><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ul><h5 id="2-动图演示-3"><a href="#2-动图演示-3" class="headerlink" title="2.动图演示"></a>2.动图演示</h5><img src="https://jellyrain.gitee.io/jellyrain-image/849589-20180331170017421-364506073.gif" width="50%" height="50%"><h5 id="3-算法分析-2"><a href="#3-算法分析-2" class="headerlink" title="3.算法分析"></a>3.算法分析</h5><p>希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。</p><h4 id="5-归并排序（Merge-Sort）"><a href="#5-归并排序（Merge-Sort）" class="headerlink" title="5.归并排序（Merge Sort）"></a>5.归并排序（Merge Sort）</h4><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 </p><h5 id="1-算法描述-4"><a href="#1-算法描述-4" class="headerlink" title="1.算法描述"></a>1.算法描述</h5><ul><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ul><h5 id="2-动图演示-4"><a href="#2-动图演示-4" class="headerlink" title="2.动图演示"></a>2.动图演示</h5><img src="https://jellyrain.gitee.io/jellyrain-image/849589-20171015230557043-37375010.gif" width="50%" height="50%"><h5 id="3-算法分析-3"><a href="#3-算法分析-3" class="headerlink" title="3.算法分析"></a>3.算法分析</h5><p>归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间。</p><h4 id="6-快速排序（Quick-Sort）"><a href="#6-快速排序（Quick-Sort）" class="headerlink" title="6.快速排序（Quick Sort）"></a>6.快速排序（Quick Sort）</h4><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><h5 id="1-算法描述-5"><a href="#1-算法描述-5" class="headerlink" title="1.算法描述"></a>1.算法描述</h5><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><h5 id="2-动图演示-5"><a href="#2-动图演示-5" class="headerlink" title="2.动图演示"></a>2.动图演示</h5><img src="https://jellyrain.gitee.io/jellyrain-image/849589-20171015230936371-1413523412.gif" width="50%" height="50%"><h4 id="7-堆排序（Heap-Sort）"><a href="#7-堆排序（Heap-Sort）" class="headerlink" title="7.堆排序（Heap Sort）"></a>7.堆排序（Heap Sort）</h4><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><h5 id="1-算法描述-6"><a href="#1-算法描述-6" class="headerlink" title="1.算法描述"></a>1.算法描述</h5><ul><li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li><li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li></ul><h5 id="2-动图演示-6"><a href="#2-动图演示-6" class="headerlink" title="2.动图演示"></a>2.动图演示</h5><img src="https://jellyrain.gitee.io/jellyrain-image/849589-20171015231308699-356134237.gif" width="50%" height="50%"><h4 id="8-计数排序（Counting-Sort）"><a href="#8-计数排序（Counting-Sort）" class="headerlink" title="8.计数排序（Counting Sort）"></a>8.计数排序（Counting Sort）</h4><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><h5 id="1-算法描述-7"><a href="#1-算法描述-7" class="headerlink" title="1.算法描述"></a>1.算法描述</h5><ul><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li></ul><h5 id="2-动图演示-7"><a href="#2-动图演示-7" class="headerlink" title="2.动图演示"></a>2.动图演示</h5><img src="https://jellyrain.gitee.io/jellyrain-image/849589-20171015231740840-6968181.gif" width="50%" height="50%"><h5 id="3-算法分析-4"><a href="#3-算法分析-4" class="headerlink" title="3.算法分析"></a>3.算法分析</h5><p>计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。</p><h4 id="9-桶排序（Bucket-Sort）"><a href="#9-桶排序（Bucket-Sort）" class="headerlink" title="9.桶排序（Bucket Sort）"></a>9.桶排序（Bucket Sort）</h4><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p><h5 id="1-算法描述-8"><a href="#1-算法描述-8" class="headerlink" title="1.算法描述"></a>1.算法描述</h5><ul><li>设置一个定量的数组当作空桶；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li><li>对每个不是空的桶进行排序；</li><li>从不是空的桶里把排好序的数据拼接起来。 </li></ul><h5 id="2-图片演示"><a href="#2-图片演示" class="headerlink" title="2.图片演示"></a>2.图片演示</h5><img src="https://jellyrain.gitee.io/jellyrain-image/849589-20171015232107090-1920702011.png" width="50%" height="50%"><h5 id="3-算法分析-5"><a href="#3-算法分析-5" class="headerlink" title="3.算法分析"></a>3.算法分析</h5><p>桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。</p><h4 id="10-基数排序（Radix-Sort）"><a href="#10-基数排序（Radix-Sort）" class="headerlink" title="10.基数排序（Radix Sort）"></a>10.基数排序（Radix Sort）</h4><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p><h5 id="1-算法描述-9"><a href="#1-算法描述-9" class="headerlink" title="1.算法描述"></a>1.算法描述</h5><ul><li>取得数组中的最大数，并取得位数；</li><li>arr为原始数组，从最低位开始取每个位组成radix数组；</li><li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li></ul><h5 id="2-动图演示-8"><a href="#2-动图演示-8" class="headerlink" title="2.动图演示"></a>2.动图演示</h5><img src="https://jellyrain.gitee.io/jellyrain-image/849589-20171015232453668-1397662527.gif" width="50%" height="50%"><h5 id="3-算法分析-6"><a href="#3-算法分析-6" class="headerlink" title="3.算法分析"></a>3.算法分析</h5><p>基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。</p><p>基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n&gt;&gt;k，因此额外空间需要大概n个左右。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>图片唱歌</title>
      <link href="2020/09/25/%E5%9B%BE%E7%89%87%E5%94%B1%E6%AD%8C/"/>
      <url>2020/09/25/%E5%9B%BE%E7%89%87%E5%94%B1%E6%AD%8C/</url>
      
        <content type="html"><![CDATA[<p>让图片能唱你想让它唱的歌。</p><p>PS：仅限好玩，不能干坏事。</p><h3 id="1-项目介绍："><a href="#1-项目介绍：" class="headerlink" title="1.项目介绍："></a>1.项目介绍：</h3><p>基于Python的软件，能把视频内人物换成你选择的照片。</p><h3 id="2-项目地址："><a href="#2-项目地址：" class="headerlink" title="2.项目地址："></a>2.项目地址：</h3><p><a href="https://github.com/dunnousername/yanderifier">GitHub</a>上的开源项目：<br><a href="https://github.com/dunnousername/yanderifier">https://github.com/dunnousername/yanderifier</a></p><h3 id="3-项目使用方法："><a href="#3-项目使用方法：" class="headerlink" title="3.项目使用方法："></a>3.项目使用方法：</h3><h4 id="1-Select-Video："><a href="#1-Select-Video：" class="headerlink" title="1.Select Video："></a>1.Select Video：</h4><p>选择唱歌的视频素材。</p><h4 id="2-Select-Lmage："><a href="#2-Select-Lmage：" class="headerlink" title="2.Select Lmage："></a>2.Select Lmage：</h4><p>选择要唱歌的图片。</p><h4 id="3-Select-Output："><a href="#3-Select-Output：" class="headerlink" title="3.Select Output："></a>3.Select Output：</h4><p>选择输出地址。</p><h4 id="4-Go："><a href="#4-Go：" class="headerlink" title="4.Go："></a>4.Go：</h4><p>开始制作。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown 进阶语法</title>
      <link href="2020/09/25/Markdown-%E8%BF%9B%E9%98%B6%E8%AF%AD%E6%B3%95/"/>
      <url>2020/09/25/Markdown-%E8%BF%9B%E9%98%B6%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>Markdown的进阶用法。</p><h3 id="Markdown-进阶用法："><a href="#Markdown-进阶用法：" class="headerlink" title="Markdown 进阶用法："></a>Markdown 进阶用法：</h3><h4 id="1-脚注："><a href="#1-脚注：" class="headerlink" title="1.脚注："></a>1.脚注：</h4><p>脚注是对文本的补充说明。</p><pre><code>[^要注明的文本][^要注明的文本]: 脚注内容</code></pre><h4 id="2-高级链接："><a href="#2-高级链接：" class="headerlink" title="2.高级链接："></a>2.高级链接：</h4><pre><code>这个链接用 1 作为网址变量 [Google][1]然后在文档的结尾为变量赋值（网址）[1]: http://www.google.com/</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown 基本语法</title>
      <link href="2020/09/24/Markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>2020/09/24/Markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p><h3 id="1-Markdown-优缺点："><a href="#1-Markdown-优缺点：" class="headerlink" title="1.Markdown 优缺点："></a>1.Markdown 优缺点：</h3><h4 id="1-优点："><a href="#1-优点：" class="headerlink" title="1.优点："></a>1.优点：</h4><p>1.因为是纯文本，所以只要支持Markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。<br>2.操作简单。Markdown只需要在标题内容前加不同数量的 # 即可选择几级标题。</p><h4 id="2-缺点："><a href="#2-缺点：" class="headerlink" title="2.缺点："></a>2.缺点：</h4><p>1.需要记一些语法（当然，是很简单。五分钟学会）。<br>2.有些平台不支持Markdown编辑模式。</p><h3 id="2-Markdown-基本语法："><a href="#2-Markdown-基本语法：" class="headerlink" title="2.Markdown 基本语法："></a>2.Markdown 基本语法：</h3><h4 id="1-标题："><a href="#1-标题：" class="headerlink" title="1.标题："></a>1.标题：</h4><p>在想要设置为标题的文字前面加#来表示<br>一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。<br>ps：标准语法一般在#后跟个空格再写文字。</p><pre><code># 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题</code></pre><h4 id="2-字体："><a href="#2-字体：" class="headerlink" title="2.字体："></a>2.字体：</h4><p><strong>加粗</strong><br>要加粗的文字左右分别用两个*号包起来</p><p><strong>斜体</strong><br>要倾斜的文字左右分别用一个*号包起来</p><p><strong>斜体加粗</strong><br>要倾斜和加粗的文字左右分别用三个*号包起来</p><p><strong>删除线</strong><br>要加删除线的文字左右分别用两个~~号包起来</p><pre><code>**这是加粗的文字***这是倾斜的文字*`***这是斜体加粗的文字***~~这是加删除线的文字~~</code></pre><h4 id="3-引用："><a href="#3-引用：" class="headerlink" title="3.引用："></a>3.引用：</h4><p>在引用的文字前加 &gt;。引用也可以嵌套，如加两个 &gt;&gt;三个 &gt;&gt;&gt; n个…</p><pre><code>&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</code></pre><h4 id="4-分割线："><a href="#4-分割线：" class="headerlink" title="4.分割线："></a>4.分割线：</h4><p>三个或者三个以上的 - 或者 * 都可以。</p><pre><code>---***</code></pre><h4 id="5-图片："><a href="#5-图片：" class="headerlink" title="5.图片："></a>5.图片：</h4><pre><code>![ 图片alt ](图片地址 &quot; 图片title &quot;)   图片alt 就是显示在图片下面的文字，相当于对图片内容的解释。   图片title 是图片的标题，当鼠标移到图片上时显示的内容。</code></pre><h4 id="6-超链接："><a href="#6-超链接：" class="headerlink" title="6.超链接："></a>6.超链接：</h4><pre><code>[ 超链接名 ](超链接地址 &quot; 超链接title &quot;)</code></pre><h4 id="7-列表："><a href="#7-列表：" class="headerlink" title="7.列表："></a>7.列表：</h4><h5 id="1-无序列表："><a href="#1-无序列表：" class="headerlink" title="1.无序列表："></a>1.无序列表：</h5><p>无序列表用 - + * 任何一种都可以</p><pre><code>- 列表内容+ 列表内容* 列表内容ps：- + * 跟内容之间都要有一个空格</code></pre><h5 id="2-有序列表："><a href="#2-有序列表：" class="headerlink" title="2.有序列表："></a>2.有序列表：</h5><p>数字加点</p><pre><code>1. 列表内容2. 列表内容3. 列表内容ps：序号跟内容之间要有空格</code></pre><h5 id="3-列表嵌套："><a href="#3-列表嵌套：" class="headerlink" title="3.列表嵌套："></a>3.列表嵌套：</h5><p>上一级和下一级之间按下一次 Tab 即可</p><h4 id="8-表格："><a href="#8-表格：" class="headerlink" title="8.表格："></a>8.表格：</h4><pre><code>表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加 ：表示文字居中-右边加 ：表示文字居右ps：原生的语法两边都要用 | 包起来。此处省略</code></pre><h4 id="9-代码："><a href="#9-代码：" class="headerlink" title="9.代码："></a>9.代码：</h4><h5 id="1-单行代码："><a href="#1-单行代码：" class="headerlink" title="1.单行代码："></a>1.单行代码：</h5><p>代码之间分别用一个反引号包起来</p><pre><code>`代码内容`</code></pre><h5 id="2-代码块："><a href="#2-代码块：" class="headerlink" title="2.代码块："></a>2.代码块：</h5><p>代码之间分别用三个反引号包起来，且两边的反引号单独占一行</p><pre><code>(```)  代码...  代码...  代码...(```)ps：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 快速搭建博客 二</title>
      <link href="2020/09/23/Hexo-%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-%E4%BA%8C/"/>
      <url>2020/09/23/Hexo-%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p>把博客部署在GitHub或者码云上</p><h3 id="1-前期准备-以下演示-GitHub-："><a href="#1-前期准备-以下演示-GitHub-：" class="headerlink" title="1.前期准备(以下演示 GitHub )："></a>1.前期准备(以下演示 GitHub )：</h3><h4 id="1-注册-GitHub-账号-自行搜索-："><a href="#1-注册-GitHub-账号-自行搜索-：" class="headerlink" title="1.注册 GitHub 账号(自行搜索)："></a>1.注册 GitHub 账号(自行搜索)：</h4><h4 id="2-启动-GitHub-的-Pages-服务-自行搜索-："><a href="#2-启动-GitHub-的-Pages-服务-自行搜索-：" class="headerlink" title="2.启动 GitHub 的 Pages 服务(自行搜索)："></a>2.启动 GitHub 的 Pages 服务(自行搜索)：</h4><h4 id="3-初始化-Git-："><a href="#3-初始化-Git-：" class="headerlink" title="3.初始化 Git ："></a>3.初始化 Git ：</h4><p><a href="https://www.github.com/">GitHub</a> 是通过 Git 进行操作的，它是一个分布式的版本控制系统，现在大部分开源软件都是由 Git 作为版本控制系统。所以之前，我们需要做一次全局的账号和邮箱的设定，用户名与邮箱和GitHub 账号注册时一致。</p><pre><code>git config --global user.name jellyraingit config --global user.email 840519987@qq.com</code></pre><h4 id="4-SSH密钥绑定："><a href="#4-SSH密钥绑定：" class="headerlink" title="4.SSH密钥绑定："></a>4.SSH密钥绑定：</h4><h5 id="1-生成SSH密钥："><a href="#1-生成SSH密钥：" class="headerlink" title="1.生成SSH密钥："></a>1.生成SSH密钥：</h5><p>输入以下命令产生 ssh 密钥，邮箱为GitHub 注册邮箱，有提示的，可一路回车键</p><pre><code>ssh-keygen -t rsa -C &quot;840519987@qq.com&quot;</code></pre><h5 id="2-上传到-GitHub"><a href="#2-上传到-GitHub" class="headerlink" title="2.上传到 GitHub :"></a>2.上传到 GitHub :</h5><p>进入到 <a href="https://www.github.com/">GitHub</a> 网站中， Settings 左边栏 SSH and GPG keys 再点击 New SSh Key ，将刚才产生的公钥内容 (C:\Users\Administrator.ssh\id_rsa.pub)  粘贴进去即可。</p><h4 id="5-部署到-GitHub-前准备："><a href="#5-部署到-GitHub-前准备：" class="headerlink" title="5.部署到 GitHub 前准备："></a>5.部署到 GitHub 前准备：</h4><h5 id="1-新建-GitHub-库："><a href="#1-新建-GitHub-库：" class="headerlink" title="1.新建 GitHub 库："></a>1.新建 GitHub 库：</h5><p>GitHub Pages 是通过创建一个名为 username(名字).github.io 的项目达成的，每个账号只能创建一个，可以参照官网 (<a href="https://pages.github.com/">https://pages.github.com/</a>) 操作。</p><h5 id="2-修改配置文件："><a href="#2-修改配置文件：" class="headerlink" title="2.修改配置文件："></a>2.修改配置文件：</h5><p>修改 _config.yaml 文件。这个文件可以修改标题，作者等信息，拉到最下面是部署的目的地，按照如下格式设定。</p><pre><code>deploy:  type: git  repository:    github: git@github.com:jellyrain/jellyrain.github.io.git  branch: master</code></pre><h4 id="6-部署到-GitHub-："><a href="#6-部署到-GitHub-：" class="headerlink" title="6.部署到 GitHub ："></a>6.部署到 GitHub ：</h4><p>先进入先前创建的目录，并且进入到该目录后右键启动 Git Bash Here，安装 Hexo git 部署插件，让 Hexo知道通过什么类型部署，这里是 git.</p><pre><code>npm install hexo-deployer-git --save</code></pre><p>开始部署到 GitHub Pages，通过如下命令 </p><pre><code>hexo clean..........hexo g..........hexo d..........</code></pre><p>最后使用浏览器打开 <a href="https://jellyrain.github.io/">https://jellyrain.github.io/</a> ，就可以看到部署到结果。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Node </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 快速搭建博客 一</title>
      <link href="2020/09/23/Hexo-%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-%E4%B8%80/"/>
      <url>2020/09/23/Hexo-%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>搭建一个部署在本地的博客</p><h3 id="1-需要的环境-自行下载-："><a href="#1-需要的环境-自行下载-：" class="headerlink" title="1.需要的环境(自行下载)："></a>1.需要的环境(自行下载)：</h3><ol><li>Node.js   </li><li>Hexo   </li><li>Git</li></ol><h3 id="2-安装环境："><a href="#2-安装环境：" class="headerlink" title="2.安装环境："></a>2.安装环境：</h3><h4 id="1-Node-js-安装："><a href="#1-Node-js-安装：" class="headerlink" title="1.Node.js 安装："></a>1.Node.js 安装：</h4><p>Hexo 是使用 <a href="https://nodejs.org/zh-cn/">Node.js</a> 开发的，所以为了安装它，我们需要先安装 <a href="https://nodejs.org/zh-cn/">Node.js</a> 工具。去官网下载安装最新版本的，安装就一路 next 即可，最后它会被加入到系统环境 path 中。<br>输入 node -v 验证是否安装成功。</p><pre><code>node -vv12.18.4</code></pre><h4 id="2-Hexo-安装："><a href="#2-Hexo-安装：" class="headerlink" title="2.Hexo 安装："></a>2.Hexo 安装：</h4><p><a href="https://nodejs.org/zh-cn/">Node.js</a> 安装好以后，同时为我们装好了 npm 工具， 这是一个包管理工具，通过它我们可以下载各种插件，cmder.exe 中输入以下命令进行安装，查看是否安装成功可以输入 hexo -v 命令 ，至此 Hexo 就安装好了。</p><pre><code>npm install hexo-cli -g---省略-----------------------------------hexo -vhexo-cli: 4.2.0os: Windows_NT 10.0.18363 win32 x64node: 12.18.4v8: 7.8.279.23-node.39uv: 1.38.0zlib: 1.2.11brotli: 1.0.7ares: 1.16.0modules: 72nghttp2: 1.41.0napi: 6llhttp: 2.1.2http_parser: 2.9.3openssl: 1.1.1gcldr: 37.0icu: 67.1tz: 2019cunicode: 13.0-----------------------------------</code></pre><h4 id="3-git-安装："><a href="#3-git-安装：" class="headerlink" title="3.git 安装："></a>3.git 安装：</h4><p>我们使用 <a href="https://git-scm.com/downloads">Git</a> 来控制Hexo的更新和部署，后期推到 <a href="https://www.github.com/">GitHub</a> 等网站也需要使用到Git，去官网下载安装最新版本的，安装就一路 next 即可。</p><pre><code>git --versiongit version 2.27.0.windows.1</code></pre><h3 id="3-本地部署"><a href="#3-本地部署" class="headerlink" title="3.本地部署:"></a>3.本地部署:</h3><h4 id="1-初始化hexo："><a href="#1-初始化hexo：" class="headerlink" title="1.初始化hexo："></a>1.初始化hexo：</h4><p>用来初始一个博客系统，随意新建一个目录，并且进入到该目录后右键启动 Git Bash Here，执行初始化 hexo init 命令。</p><h4 id="2-本地部署："><a href="#2-本地部署：" class="headerlink" title="2.本地部署："></a>2.本地部署：</h4><p>还是在该目录后右键启动 Git Bash Here，执行命令启动本地部署。</p><pre><code>hexo g......hexo s......</code></pre><p>然后在浏览器中输入 <a href="http://localhost:4000/">http://localhost:4000/</a> 就可以查看刚才本地部署的博客，至此本地博客系统已经成功架起来了，按下<em>ctrl+c</em> 关闭部署状态。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Node </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
